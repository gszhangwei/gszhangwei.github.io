<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gszhangwei.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Willie&#39;s Blog">
<meta property="og:url" content="hhttps://gszhangwei.github.io/page/2/index.html">
<meta property="og:site_name" content="Willie&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wiilie Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="hhttps://gszhangwei.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Willie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Willie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/03/21/AI-workflows-improve-software-development-efficiencyt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/21/AI-workflows-improve-software-development-efficiencyt/" class="post-title-link" itemprop="url">AI-Workflow革命：2天任务仅需50分钟！</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-21 17:00:00" itemprop="dateCreated datePublished" datetime="2025-03-21T17:00:00+08:00">2025-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-31 17:57:46" itemprop="dateModified" datetime="2025-03-31T17:57:46+08:00">2025-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Hade1vZDIRMwbTyZxB0-Hg">《结构化提示词驱动开发实践》</a>发布以来，我收到的反馈中有两个核心诉求格外突出：降低方法论应用门槛和提供可直接复用的实践模板。<br>作为亲历从传统开发到AI辅助编程转变的实践者，我深感当下软件开发正经历双重变革：行业迭代加速与生成式AI引发的效率革命。当AI生成代码的通过率从30%跃升至95%，这预示着开发范式的根本性转变。<br>面对方法论”知易行难”的现实，是否可以通过”<strong>使用-理解-创新</strong>“的渐进模式，让开发者在获得即时成果的同时自然习得方法论精髓？<br>其实，在《结构化提示词驱动开发实践》方法论中的<strong>通用方案层</strong>恰好可作为破局关键 - <strong>构建可重复使用的抽象的解决方案模板</strong>。<br><br><img src="/../images/Prompts_engineering_strategies.png" alt="Prompts_engineering_strategies.png"><br><br>实测表明，这种模板化方案将新手<strong>构建有效Prompt</strong>的时间<strong>从2小时缩短至30分钟</strong>，Prompt输出质量提升50%以上。<br>本文将分享一套经过50余个开发任务验证的AI增强工作流，通过5阶段14个精炼步骤，将传统开发中耗时2天的任务最短压缩至55分钟内完成，效率最高提升16倍。无论你是AI开发新人还是资深工程师，希望这套融合结构化思维与AI辅助的工作流都能为你开启效率新维度。</p>
<h2 id="背景与工具生态"><a href="#背景与工具生态" class="headerlink" title="背景与工具生态"></a><strong>背景与工具生态</strong></h2><h3 id="传统开发流程的局限性"><a href="#传统开发流程的局限性" class="headerlink" title="传统开发流程的局限性"></a><strong>传统开发流程的局限性</strong></h3><p>传统软件开发流程通常包含需求分析、设计、编码、测试和部署等环节。尽管敏捷方法论提高了迭代速度，但开发者仍需手动完成大量重复性工作：编写样板代码、构建测试用例、处理边界条件等。这些任务虽然必要，却占用了大量本可用于创新和解决核心业务问题的时间。</p>
<h3 id="核心工具介绍"><a href="#核心工具介绍" class="headerlink" title="核心工具介绍"></a><strong>核心工具介绍</strong></h3><p>我的AI辅助开发工作流主要基于以下工具构建：</p>
<ul>
<li><strong>Cursor</strong>：AI驱动的代码编辑器，支持代码补全、重构和智能对话</li>
<li><strong>Jira MCP Server</strong>：获取和管理业务需求的项目管理工具</li>
<li><strong>Aupro</strong>：我们构建的工程实践治理平台，使技术治理团队能够制定和共享代码交付标准，从而使AI代码助手能够生成高质量的代码。（如果暂时没有这样的平台也不要紧，可以手动将模板放到本地管理起来）</li>
<li><strong>各类测试框架</strong>：例如JUnit 5 (Jupiter)等，配合工作流实现自动化测试</li>
</ul>
<h3 id="AI增强软件开发工作流方案详解"><a href="#AI增强软件开发工作流方案详解" class="headerlink" title="AI增强软件开发工作流方案详解"></a><strong>AI增强软件开发工作流方案详解</strong></h3><p>这套AI增强软件开发工作流是一个系统化的14步流程，将AI工具融入软件开发的各个环节，从技术需求分析到代码提交。通过实践证明，这套工作流可以将原本需要两天完成的工作量（如创建一个根据给出的动态查询条件，进行资源分页查询API及其完整测试场景）压缩到1小时内完成，效率提升显著。抽象的步骤如下：<br><br><img src="/../images/AI_workflow.png" alt="AI_workflow.png"></p>
<h3 id="AI增强软件开发工作流：5阶段14步骤详细解析"><a href="#AI增强软件开发工作流：5阶段14步骤详细解析" class="headerlink" title="AI增强软件开发工作流：5阶段14步骤详细解析"></a><strong>AI增强软件开发工作流：5阶段14步骤详细解析</strong></h3><ul>
<li><p><strong>需求分析与规划阶段</strong></p>
<ul>
<li>需求分析与解决方案构思<ul>
<li>首先检索相似任务的历史实现和最佳实践，建立知识基础</li>
<li>与AI协作探索技术方案，快速评估不同实现路径的可行性和优劣</li>
<li>明确定义AI需要解决的具体问题，设定预期成果和成功指标</li>
<li>这一步奠定了整个开发过程的基础，清晰的问题定义让后续AI生成更精准高效</li>
</ul>
</li>
<li>需求结构化<ul>
<li>利用AI的自然语言处理能力将业务需求转换为结构化用户故事</li>
<li>确保需求描述完整且包含明确的验收标准和预期结果</li>
<li>这一步将抽象业务概念转化为明确的技术任务，减少需求理解偏差</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>设计与方案定义阶段</strong></p>
<ul>
<li><p>实现方案设计</p>
<ul>
<li>应用预先总结的方案模板，生成结构化prompts</li>
<li>明确定义技术路径、数据结构、接口定义和关键业务逻辑实现细节</li>
<li>为复杂功能设计分层实现策略，将大任务分解为可管理的小模块</li>
<li>高质量的prompt是获得高质量代码输出的关键，需结合业务知识和技术经验设计</li>
</ul>
</li>
<li><p>方案细节调整与优化</p>
<ul>
<li>全面评估生成的prompts质量、完整性和技术可行性</li>
<li>分析方案是否考虑了可扩展性、性能和长期维护需求</li>
<li>根据业务需求和技术限制调整实现策略，预见潜在问题</li>
<li>这一步相当于传统开发中的架构评审，确保实现方向正确无误</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>代码开发与实现阶段</strong></p>
<ul>
<li><p>代码生成与初步验证</p>
<ul>
<li>利用优化后的prompts生成实现代码，包括基础架构和核心功能</li>
<li>通过快速验证检查基本功能和代码结构是否符合预期</li>
<li>评估生成代码是否遵循项目编码规范和最佳实践</li>
</ul>
</li>
<li><p>代码审核与prompt微调</p>
<ul>
<li>细致检查代码质量、性能、安全性和边界处理</li>
<li>识别代码中的潜在”代码异味”(Code Smells)和可优化点</li>
<li>针对性调整prompt以解决发现的问题，进行明确的修正指导</li>
<li>这是一个迭代优化过程，通过prompt精确调整不断提高代码质量</li>
</ul>
</li>
<li><p>代码最终生成</p>
<ul>
<li>使用定稿prompts重新生成优化后的实现代码</li>
<li>确保代码风格一致性、可读性和最佳实践遵循</li>
<li>验证代码是否包含适当的注释和文档化</li>
<li>定稿的prompt包含前几轮迭代中的优化经验，生成的代码质量显著提高</li>
</ul>
</li>
<li><p>功能验证</p>
<ul>
<li>手动验证核心功能和边界场景，确保功能完整性</li>
<li>执行静态代码分析，检查代码质量指标和潜在问题</li>
<li>验证代码与现有系统的兼容性和集成点</li>
<li>验证过程既检查功能正确性，也关注代码可维护性和性能优化空间</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>测试与质量保障阶段</strong></p>
<ul>
<li><p>测试设计</p>
<ul>
<li>基于<strong>解决方案实现细节prompts</strong>，结合总结的测试Prompt模板，生成结构化测试用例</li>
<li>确保测试覆盖正常流程、边界条件和异常处理场景</li>
<li>良好的测试设计能防止未来的回归问题，并作为代码功能的活文档</li>
</ul>
</li>
<li><p>测试规划确认</p>
<ul>
<li>审核测试场景的完整性和适当性，确保测试范围全面</li>
<li>确保测试不仅覆盖正常情况，也包含异常处理和各种边界条件</li>
</ul>
</li>
<li><p>测试代码生成与执行</p>
<ul>
<li>使用测试prompts生成自动化测试代码，确保测试代码质量</li>
<li>执行自动化测试并收集详细结果，分析测试覆盖率</li>
<li>验证测试是否能有效发现潜在问题和边界情况</li>
<li>AI生成的测试通常比手写测试更全面，能覆盖更多边界情况和异常路径</li>
</ul>
</li>
<li><p>问题修复与迭代</p>
<ul>
<li>根据测试结果分类问题原因，建立优先修复顺序</li>
<li>针对性进行修复，区分处理策略：<ul>
<li>对于未覆盖的边界场景，修改实现代码并更新对应prompts</li>
<li>对于测试数据问题，优化测试数据而不更改实现逻辑</li>
</ul>
</li>
<li>重复测试直至全部通过，确保代码质量和稳定性</li>
<li>记录修复过程中的经验和发现，作为prompt模版优化的素材</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>交付与知识管理阶段</strong></p>
<ul>
<li><p>集成与提交</p>
<ul>
<li>确保代码与现有系统完全兼容，验证所有集成点正常工作</li>
<li>提交代码和结构化Prompts方案，便于团队理解开发思路</li>
</ul>
</li>
<li><p>知识沉淀</p>
<ul>
<li>提炼有效prompt模式并更新团队模板库，形成可复用资产</li>
<li>总结经验教训，记录成功策略和遇到的挑战</li>
<li>分享创新实践和技术突破，促进团队整体能力提升</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="核心优势与潜在挑战"><a href="#核心优势与潜在挑战" class="headerlink" title="核心优势与潜在挑战"></a>核心优势与潜在挑战</h2><ul>
<li><strong>核心优势：</strong><ul>
<li>结构化流程使开发过程更加条理化和可预测</li>
<li>利用模板和AI生成提高了代码和测试的一致性和完整性</li>
<li>多层次验证确保代码质量，从设计到实现到测试全覆盖</li>
<li>显著提升效率，能将两天工作量缩减至一小时内完成</li>
</ul>
</li>
<li><strong>潜在挑战：</strong><ul>
<li>工作流效果很大程度依赖于AI响应的质量和精准度（目前claude-3.7-sonnet完全够用）</li>
<li>过度依赖AI可能导致对生成代码理解不足</li>
<li>Prompt工程需要专业技能和持续调优</li>
<li>需要注意生成代码的文档质量和可维护性</li>
</ul>
</li>
</ul>
<h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><p>理论终需实践验证。为了直观展示方法论的实际效果，我录制了完整的开发实例视频，欢迎各位观摩并提出宝贵意见。<br><a href="">点击观看视频演示</a>。视频中所展示的流程，整体如下所示：<br></p>
<div style="text-align: center;"><img src="../images/AI_workflow_sequence_diagram.png" alt="AI_workflow_sequence_diagram"></div>
<div style="text-align: center;"><span style="font-size: x-small; color: grey; ">Workflow关键的工作时序</span></div>

<h2 id="最佳实践与经验总结"><a href="#最佳实践与经验总结" class="headerlink" title="最佳实践与经验总结"></a>最佳实践与经验总结</h2><p>有效的prompt是整个工作流的核心，以下是一些关键技巧：</p>
<ul>
<li><strong>先抽象再具体</strong>：从框架搭建开始，而非一开始就陷入细节。先定义清楚实现功能的抽象步骤以及各步骤之间的关联关系，然后再根据这些抽象步骤，以有效构建提示词的指导思想，逐个进行细化。这种”自顶向下”的方法可以确保生成的代码结构合理、层次分明。</li>
<li><strong>结构化信息提供</strong>：以结构化提示词驱动开发的指导思想，描述解决方案，明确代码生成路径。结构化的prompt不仅使AI更易理解开发意图，也使后续的迭代和调整更加清晰可控，为代码质量奠定基础。</li>
<li><strong>上下文关联管理</strong>：在prompt中包含必要的关联信息，如业务建模之间的继承关系，使用的框架各层之间的调用关系等。良好的上下文关联使AI能够理解系统整体架构，生成符合既定架构风格和设计理念的代码，减少后期重构需求。</li>
<li><strong>版本控制</strong>：对有效prompt进行管理，形成可复用的模板库。随着项目进展，不断积累和优化prompt模板，逐步形成适合团队和项目特点的prompt资产库，提升长期效率。</li>
</ul>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>未来，我们将重点优化以下两个方面，充分发挥 AI 的能力：首先是提升 Workflow 的自动化程度；其次是构建 Prompt 自进化体系。该体系不仅依靠人工总结，更侧重于 AI 的智能学习，使其能基于优质 Prompt 实现方案，定期生成高质量模板。</p>
<ul>
<li><strong>自动化程度提升</strong>：通过自动化开发流程中的更多环节，例如基于需求自动创建 Jira Story、触发自动化代码审查等，来减少手动操作，提高流程一致性和效率。</li>
<li><strong>Prompt自进化体系</strong>：建立基于强化学习的 Prompt 模板演进体系，使 AI 能够学习现有模板库中的成功模式，并根据用户反馈和需求变化，自动优化模板并生成新的解决方案，形成持续改进的良性循环。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>AI辅助开发不仅是效率工具引入，更是软件开发范式的转变。通过本文介绍的AI辅助开发工作流，开发者可以实现与AI的高效协作，将重复性工作交由AI处理，而自身则专注于更具创造性和战略性的任务。<br>实践证明，采用这套工作流可以将开发效率提升至少3倍，同时保持甚至提高代码质量。随着AI技术的持续进步，这种效率提升还有更大空间。对于个人开发者和团队而言，现在正是拥抱这一变革的最佳时机。<br>掌握AI辅助开发不是要取代开发者的角色，而是重新定义我们的工作方式。真正的价值在于人机协作——AI负责执行和辅助，人类负责创新和决策。未来的顶尖开发者将是那些既精通技术本身，又能有效指导AI完成任务的复合型人才。<br>让我们积极拥抱这一变革，重新思考软件开发的本质，并在人机协作的新时代中创造更大的价值。</p>
<h2 id="最后，对于代码本质的一些思考"><a href="#最后，对于代码本质的一些思考" class="headerlink" title="最后，对于代码本质的一些思考"></a>最后，对于代码本质的一些思考</h2><p>代码的本质是人类意图的符号化表达，它是随着技术浪潮不断演化的。从早期的打孔纸带到汇编语言，从C++到Python、Java，每一次技术革新都拓展了我们对”何为代码”的理解边界。自然语言编程并非对传统编程的替代，而是编程范式自然演进的延伸——当AI能够精准理解人类意图与语境需求时，代码的表达方式自然而然地向更接近人类思维的形态靠拢。<br>不同的编程范式各有其价值与适用场景，就如同历史上各种交通工具的演进一样，新技术的出现并不意味着旧技术的全面淘汰。富有远见的开发者往往能够兼容并蓄：精通传统编程的严谨结构，同时探索prompt工程的无限可能，未来或许还能开拓更直接的人机交互方式。在这技术变革的洪流中，洞悉技术背后的本质原理与保持开放的学习心态，远比拘泥于某种具体实现形式更为宝贵——因为代码的形态会不断迭代，而创新的精神却是恒久不变的。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>本文收录了，基于结构化提示词驱动开发方法论，创建的API相关CRUD操作以及测试模板集（<a target="_blank" rel="noopener" href="https://github.com/gszhangwei/structured-prompts-driven-development/tree/main"><strong>点击这个链接</strong></a>），这些模板已经过实践验证并可直接应用于日常开发。诚挚地邀请各位开发者在使用这些基础模板的同时，根据自身项目需求进行创新与扩展，共同推动这一方法论的持续演进。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/02/27/prompts-driven-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/prompts-driven-development/" class="post-title-link" itemprop="url">结构化提示词驱动开发实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 17:00:00" itemprop="dateCreated datePublished" datetime="2025-02-27T17:00:00+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-28 16:48:41" itemprop="dateModified" datetime="2025-02-28T16:48:41+08:00">2025-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上周六参加了公司组织的关于AI实践的对外直播，我分享的内容是《结构化提示词驱动开发实践》。现在将其记录成一篇博客，在此与大家分享我们团队在提示词驱动开发领域的一些实践与思考。随着大语言模型的不断成熟，我们逐步认识到，如何高效运用结构化提示词，引导AI生成高质量代码，已成为提升软件开发效率与质量的关键所在。本文将围绕“<strong>结构化提示词驱动开发</strong>”这一主题，从设计理念、实践路径到治理策略，全面解析提示词在软件开发中如何落地应用，并以数据与实例展示其显著成效。</p>
<h2 id="解锁解决方案：克服关键挑战"><a href="#解锁解决方案：克服关键挑战" class="headerlink" title="解锁解决方案：克服关键挑战"></a>解锁解决方案：克服关键挑战</h2><p>在早期的AI辅助开发过程中，我们曾经深刻体会到传统开发模式的诸多局限。常规的对话式代码生成往往存在如下问题：生成的代码可用性不足、质量参差不齐，以至于后续大量人工返工成为常态；同时，对话式生成方案不易形成固化、可复用的工程产物，制约了AI在工程级项目中的大规模应用。数据显示，AI生成代码的采纳率普遍低于50%，而代码质量的波动也使得实际交付面临诸多风险。</p>
<p>正因如此，我们开始思考：如果能够突破这些障碍，充分激发AI在交付过程中的潜能，那么软件开发的方式将会迎来怎样的变革？经过反复探索与实践，我们认为解决这一问题需要三大能力作支撑：</p>
<ul>
<li>第一是迅速分析问题，并精准识别出根本原因，从而为后续提供有效解决方案；</li>
<li>第二是依托严谨的工程实践，通过标准流程来保障代码质量；</li>
<li>第三也是最为关键的，即通过使用结构化提示词，让AI生成的代码具备可解释性、可追溯性和高采纳率。<br><img src="/../images/Challenge_and_Solution.png" alt="Challenge_and_Solution.png"><br>正是这三大支柱构成了我们突破传统模式、推动AI赋能开发的核心思路，也为后续实践提供了坚实的理论基础和指导方向。</li>
</ul>
<h2 id="试点项目探索与验证"><a href="#试点项目探索与验证" class="headerlink" title="试点项目探索与验证"></a>试点项目探索与验证</h2><p>为了验证这一方法论的可行性，我们开展了一系列试点项目，尽管具体业务细节不便透露，但整体项目任务包括了前端服务的初始化、基础设施及持续集成（CI）的搭建、前后端代码与测试的新编写，以及现有前端系统的重构。项目交付后，通过对数据的详细采集与对比分析，我们获得了非常振奋的成果。</p>
<p>例如，在从零开始构建系统的任务中，传统开发模式需要消耗约19人天，而采用结构化提示词模式后，仅耗时7人天，且代码采纳率高达95%，这不仅大幅缩短了开发周期，也使得生产力实现近3倍的提升。而针对遗留系统的需求响应，开发时间则由原先的5人天缩短至3人天，生产效率提升约1.7倍。此外，我们还观察到，通过这种模式，代码重复率显著降低，单元测试覆盖率由65%增加至96%。这些数据充分说明，结构化提示词不仅提高了交付效率，更在实际工程中提升了代码质量和系统稳定性。<br><img src="/../images/Background_of_Project.png" alt="Background_of_Project.png"><br>数据背后的意义在于，我们成功为AI赋能软件开发找到了一条有效路径，这种路径打破了传统开发方式的局限，将原本模糊难控的生成过程转化为可管理、可复制的工程实践，为整个团队带来了崭新的开发体验和惊人的效率提升。</p>
<p>让我们先探讨如何在软件开发领域中构建有效提示词，再逐步回顾我们所做的具体实践。</p>
<h2 id="结构化提示词设计框架"><a href="#结构化提示词设计框架" class="headerlink" title="结构化提示词设计框架"></a>结构化提示词设计框架</h2><h3 id="如何有效构建提示词？"><a href="#如何有效构建提示词？" class="headerlink" title="如何有效构建提示词？"></a>如何有效构建提示词？</h3><p>在软件开发领域利用自然语言驱动AI生成代码过程中，一个根本性矛盾一直存在：人类思维具有天然的发散性，而AI执行指令则要求极高的结构化和精确性。传统提示词设计容易陷入两种误区：一方面，开发者可能过分依赖表面化描述，如直接要求“生成800字带小标题的营销文案”，这种方式虽然直白，但往往流于形式；另一方面，则可能陷入抽象概念的模糊描述，让AI自行揣测具体意图，从而导致输出偏离预期目标。</p>
<p>为突破这一矛盾，我们强调思维方式的跃迁，即要从简单的特征描述（例如颜色、形状等外在属性）转向对事物本质的抽象提炼（例如功能内核与运行机制）。只有当我们首先明确定义对象的核心功能与本质特性，再辅以具体细节描述，才能为AI提供一条唯一且明确的生成路径，最大程度降低AI的幻觉。例如，在需要生成一个“白色冰箱”的场景中（假设我们并不知道冰箱这一名词概念），如果仅以“生成一个四方形白色物体，下方有四个小轮子”进行描述，可能误导AI产生与冰箱无关的对象；而若从本质出发，先定义“维持低温环境”这一核心功能，然后再补充其它特征，便能精准锁定冰箱这一概念，同时也为其它如冷库、冷链车留下一定扩展空间。正如我们所倡导的，“特征决定细节，本质决定边界”，只有先明晰本质，后注重具体细节，才能确保生成结果符合预期。<br><img src="/../images/Construct_prompts_effectively.png" alt="Construct_prompts_effectively.png"></p>
<h3 id="组件描述法在提示词构建中的实践"><a href="#组件描述法在提示词构建中的实践" class="headerlink" title="组件描述法在提示词构建中的实践"></a>组件描述法在提示词构建中的实践</h3><p>基于上述理念，在构建提示词时我们引入了组件描述法。以后端开发为例，我们为每个组件设计了涵盖类名、方法名、异常处理等在内的多达10个标准化维度。通过这种方法，每个组件不仅能够明确界定其功能边界，也实现了逻辑上的严谨封装。需要说明的是，这里的“组件”概念与传统开发框架中的概念有所不同，它指的是构成结构化提示词的基本单元，是对功能职责和实现过程的细致拆解。<br><img src="/../images/Component_Description.png" alt="Component_Description.png"><br>组件描述法的引入，使得每个提示词单元既自成体系又相互衔接，在明确各自核心职责的同时，通过精准定义其属性和操作范围，有效避免了各组件之间的混淆和重叠，保障了整体提示词的严密性和生成代码的一致性。这样的设计不仅极大增强了系统的可维护性，也为处理复杂业务场景提供了有力支撑。</p>
<h3 id="结构化Prompt设计整体框架"><a href="#结构化Prompt设计整体框架" class="headerlink" title="结构化Prompt设计整体框架"></a>结构化Prompt设计整体框架</h3><p>在组件定义的基础上，我们进一步构建了完整的结构化Prompt设计框架，该框架总体分为以下五个部分：</p>
<p>需求锚定阶段要求我们准确描述业务需求，确保开发目标的精准定位；结构定义阶段则负责明确实现功能所需模块之间的依赖关系和相互作用；任务编排阶段将整体需求拆解成具体操作单元，通过逐一定义各组件来形成连续的工作流；在通用任务阶段，我们对数据校验、异常处理等高频操作进行标准化处理，以模板化的方式复用解决方案；最后，约束控制阶段为整个系统设置安全围栏，限定组件调用的范围和引用关系，防止因边界不清引发的潜在问题。</p>
<p>在此过程中，我们始终坚持两个黄金准则：首先，本质抽象必须优先于特征描述，只有清晰定义组件的核心职责，才能避免陷入形式化穷举的困境；其次，组件应被视为逻辑单元，而非仅仅是代码片段，就如一部优秀剧本强调刻画人物内在动机，而非干涉演员细微表现。正是在这两个准则的指引下，结构化Prompt设计框架为团队构建了一套系统、严谨且高效的提示词应用体系，极大地提升了整体开发效率和代码质量。<br><img src="/../images/Structured_prompts_strategy.png" alt="Structured_prompts_strategy.png"></p>
<h2 id="提示词工程：AI资产的治理策略"><a href="#提示词工程：AI资产的治理策略" class="headerlink" title="提示词工程：AI资产的治理策略"></a>提示词工程：AI资产的治理策略</h2><p>要确保提示词在长期开发过程中的持续有效性，仅仅构建高质量提示词是不够的，还需要建立一套完善的治理策略。我们将提示词治理分为多个层级：规则层、行业垂直方案抽象层、解决方案具体实现层以及AI执行层。各层级之间分工明确，架构师、技术负责人与开发工程师各自履行职责，共同维护提示词资产的高标准和可持续性。<br><img src="/../images/prompts_governance_policy.png" alt="prompts_governance_policy.png"><br>目前，在试点项目中，我们已经通过预定义工作流引入日志规则，将其置于规则层，确保在代码生成前通过提示词预先注入必要的安全和质量标准。这不仅使得生成代码符合日志规范，同时也为整个系统构建起一道坚固的防护屏障。随着实施的不断推进，这一治理策略将逐步完善并推广到更广泛的开发场景中，为软件工程在质量控制和流程管理上提供制度化保障。</p>
<h2 id="项目实践实例解析"><a href="#项目实践实例解析" class="headerlink" title="项目实践实例解析"></a>项目实践实例解析</h2><p>为了更直观地展示结构化提示词的应用效果，我们以一个获取用户权限信息的API项目为例进行说明。该API不仅需支持根据用户ID、邮箱、姓名及角色进行多条件查询，还要求具备分页、排序以及对数据进行分组合并的功能。在实际开发中，我们依照需求、结构、任务、通用任务与约束控制等模块，系统地组织和编写提示词，同时在组件定义中严格遵循组件描述法和构建提示词的核心指导思想。依托这一完备的体系，我们最终实现了一个能够根据多参数动态构建查询条件，并对数据进行复杂分组与合并操作的API。</p>
<p>统计结果显示，在后端实现API模块，团队共使用6组提示词，总行数达592行，最终生成代码1849行，涉及37个文件的新增或修改。如此覆盖复杂业务场景的实践成果，不仅充分验证了结构化提示词模式的可行性，也大大提升了交付效率和代码质量，为传统开发模式带来了全新的变革思路。<br><img src="/../images/Examples_of_project_practices.png" alt="Examples_of_project_practices.png"><br>在项目推进过程中，我们也直面了一些实际问题，并据此积累了宝贵经验。尤其对于初次接触该模式的团队而言，我们发现并不需要从零开始书写提示词，而可以从现有代码中提炼有效提示，从而逐步优化和完善提示体系，实现快速落地和迭代。</p>
<h2 id="有效撰写提示词的技巧与实战建议"><a href="#有效撰写提示词的技巧与实战建议" class="headerlink" title="有效撰写提示词的技巧与实战建议"></a>有效撰写提示词的技巧与实战建议</h2><p>通过多次项目实践，我们总结出如下几种撰写高质量提示词的有效策略。首先，当解决方案已经存在于现有代码中时，可以利用AI自动解析代码，提取出有效提示词，并在此基础上进行优化，这种做法既节约了时间，也避免了从零开始的风险。其次，当解决方案尚存于开发者脑海时，借助可复用的结构化策略，并根据不同任务灵活调整细节，能迅速形成符合预期的提示词。对于那些暂时无解的情况，我们建议先与AI展开开放性协作探索，通过不断收敛思路后，借助结构化模板生成初步提示词，再由开发者进行必要的人工微调和确认。</p>
<p>在实践中我们还发现，写作提示词时应特别注意避免过度抽象。对于简单场景，往往无需构建复杂的提示体系，此时采用直接的对话式编程反而更为高效。此外，提示词的撰写要做到本质与特征兼顾——既要确保功能和职责的清晰表述，又不能忽略细节描述的重要性。最关键的是，无论是为了让AI生成优秀代码，还是为了便于开发者后期审核修正，最终形成的提示词都必须具备良好的可读性和实用性，能够以清晰自然的语言传达预期意图。<br><img src="/../images/Advice_of_practice.png" alt="Advice_of_practice.png"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总体而言，提示词驱动开发作为一种全新的软件开发模式，展现出前所未有的创新潜力。凭借结构化提示词的系统设计与严格治理策略，我们不仅成功激发了AI在代码生成中的潜能，还显著提升了开发效率和代码质量，为我们团队引入了全新的思考方式和工作模式。</p>
<p>展望未来，我们将持续关注AI技术的前沿动态，并在更为复杂的实际场景下不断完善提示词设计与治理体系。我们期待，在广大开发者不断探索和实践的推动下，人与AI的深度融合能够开启软件开发的新纪元，共同推动整个行业迈向更高效、更智能的未来。通过不断迭代与优化，相信结构化提示词必将成为工程实践中的一项核心技术，为软件开发注入源源不断的创新动力和竞争优势。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>这篇文章在外部发表后，大家围绕“特征决定细节，本质决定边界”展开了一些讨论。但我发现，大家对“特征”和“本质”的基本定义可能存在不同理解。为此，我在这里补充了它们的基本定义，以便统一认知，从而帮助大家更好地理解这句话的深层含义。<br>特征（Features）：指问题或需求中可观测、可描述的具体属性，包括输入输出形式、约束条件、交互场景、技术参数等显性要素。核心特点：可量化，可验证，具象化（容易观察到的）。<br>本质（Essence）：指问题背后需要解决的根本矛盾或核心目标，是决定解决方案有效性的底层逻辑。核心特点：抽象性，方向性，不可妥协性（那个能够决定成为它的东西）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/02/27/prompt-driven-development-en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/prompt-driven-development-en/" class="post-title-link" itemprop="url">Structured prompts driven development</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 17:00:00" itemprop="dateCreated datePublished" datetime="2025-02-27T17:00:00+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-03 12:07:28" itemprop="dateModified" datetime="2025-03-03T12:07:28+08:00">2025-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Recently, I took part in an external livestream hosted by our company in China, where I presented on the topic of ‘Structured Prompt-Driven Development Practice. I am now recording this experience as a blog post to share some of our team’s practices and reflections on prompt-driven development. As large language models continue to mature, we are increasingly realizing that efficiently leveraging structured prompts to guide AI in generating high-quality code is key to improving both software development efficiency and quality. This article, centered on <strong>Structured Prompt-Driven Development</strong>, comprehensively analyzes how prompts can be applied in software development—from design philosophy and practical implementation to governance strategies—supporting our discussion with data and practical examples.</p>
<h2 id="Unlocking-Solutions-Overcoming-Key-Challenges"><a href="#Unlocking-Solutions-Overcoming-Key-Challenges" class="headerlink" title="Unlocking Solutions: Overcoming Key Challenges"></a>Unlocking Solutions: Overcoming Key Challenges</h2><p>In the early stages of AI-assisted development, we experienced firsthand the many limitations of conventional development models. The typical conversational code generation approach often suffers from several issues: the generated code frequently lacks usability and exhibits uneven quality, leading to extensive manual rework; moreover, conversational generation methods do not readily produce fixed, reusable engineering deliverables, which limits the large-scale application of AI in enterprise-level projects. Data shows that the adoption rate of AI-generated code is generally below 50%, and the fluctuations in code quality pose significant risks for actual delivery.</p>
<p>This led us to ponder: if we could overcome these obstacles and fully harness the potential of AI during the delivery process, how might software development transform? After extensive exploration and practical trials, we determined that addressing these challenges requires three core capabilities:</p>
<ul>
<li>The ability to quickly analyze problems and accurately identify root causes, thereby providing effective subsequent solutions.</li>
<li>A reliance on rigorous engineering practices that ensure code quality through standardized processes.</li>
<li>Most critically, employing structured prompts that enable AI to generate code which is interpretable, traceable, and highly adoptable.</li>
</ul>
<p>Challenge_and_Solution.png</p>
<p>These three pillars form the core of our breakthrough from traditional methodologies and drive our AI-empowered development approach, providing a solid theoretical foundation and clear guidance for our subsequent practices.</p>
<h2 id="Pilot-Project-Exploration-and-Validation"><a href="#Pilot-Project-Exploration-and-Validation" class="headerlink" title="Pilot Project Exploration and Validation"></a>Pilot Project Exploration and Validation</h2><p>To validate the feasibility of our methodology, we conducted a series of pilot projects. Although specific business details cannot be disclosed, the overall project tasks included initializing new frontend services, setting up infrastructure and continuous integration (CI), writing new backend and frontend code and tests, and refactoring existing frontend systems. After project delivery, detailed data collection and comparative analysis yielded remarkably encouraging results.</p>
<p>For instance, in a system built from scratch, the traditional development model required approximately 19 man-days, whereas the structured prompt-driven approach took only 7 man-days—with a code adoption rate as high as 95%. This not only reduced the development cycle dramatically but also nearly tripled productivity. Similarly, for legacy system requirements, development time was reduced from 5 to 3 man-days, representing about a 1.7-times improvement in efficiency. Additionally, we observed a significant reduction in code duplication and an increase in unit test coverage from 65% to 96%. These results clearly demonstrate that structured prompts not only improve delivery efficiency but also enhance code quality and overall system stability.</p>
<p>Background_of_Project.png</p>
<p>The significance of these results is that we have successfully discovered an effective path to harness AI for software development. This approach breaks through the limitations of traditional methods by transforming the inherently ambiguous generation process into a manageable, replicable engineering practice—bringing our team a brand-new development experience along with astonishing efficiency gains.</p>
<p>Let’s first explore how to construct effective prompts in the realm of software development, and then review our specific practices.</p>
<h2 id="Structured-Prompt-Design-Framework"><a href="#Structured-Prompt-Design-Framework" class="headerlink" title="Structured Prompt Design Framework"></a>Structured Prompt Design Framework</h2><h3 id="How-to-Construct-Effective-Prompts"><a href="#How-to-Construct-Effective-Prompts" class="headerlink" title="How to Construct Effective Prompts?"></a>How to Construct Effective Prompts?</h3><p>In software development, using natural language to drive AI code generation presents a fundamental contradiction: human thinking is inherently divergent, while AI requires highly structured and precise instructions. Traditional prompt design can fall into two pitfalls. On one hand, developers might overly rely on superficial descriptions—such as simply asking “Generate an 800-word marketing copy with subheadings.” Although straightforward, this approach often turns out to be formulaic. On the other hand, overly abstract descriptions leave too much room for interpretation, causing AI to stray from the intended target.</p>
<p>To overcome this contradiction, we emphasize a shift in thinking—from merely describing features (like color or shape) to abstracting the essence of an object (its core functionality and operational mechanism). Only by first clearly defining an object’s core function and essential characteristics, and then supplementing that with specific details, can we provide AI with a unique, unambiguous generation path that minimizes “hallucinations.” For example, consider a scenario where we need to generate a “white refrigerator” (assuming we are not familiar with the abstract concept of a refrigerator). If we only describe it as “a square white object with four small wheels at the bottom,” AI might produce something unrelated to a refrigerator. However, if we begin by defining its essential function as “maintaining a low-temperature environment” and then add additional feature details, we can accurately target the concept of a refrigerator while still leaving room for related ideas such as cold storage or refrigerated trucks. As we advocate, “features determine details, while essence defines boundaries.” Only by clearly articulating the essence first and then supplementing with specifics can we ensure that the generated outcome aligns with our expectations.</p>
<p>Construct_prompts_effectively.png</p>
<h3 id="Application-of-the-Component-Description-Method-in-Prompt-Construction"><a href="#Application-of-the-Component-Description-Method-in-Prompt-Construction" class="headerlink" title="Application of the Component Description Method in Prompt Construction"></a>Application of the Component Description Method in Prompt Construction</h3><p>Based on the above philosophy, we introduced the component description method into our prompt construction. Taking backend development as an example, we designed up to 10 standardized dimensions for each component, covering aspects such as class names, method names, and exception handling. This method does not simply replicate the conventional framework concept; rather, the “components” here represent the basic units of a structured prompt that break down both functional responsibilities and the implementation process in detail.</p>
<p>Component_Description.png</p>
<p>The introduction of the component description method ensures that each prompt element is both self-contained and seamlessly integrated with others. By clearly defining its core responsibility and precisely specifying attributes and operational scope, we effectively avoid confusion and overlap between components, thereby safeguarding the integrity of the overall prompt and ensuring consistency in the generated code. This design not only significantly enhances maintainability but also provides robust support for tackling complex business scenarios.</p>
<h3 id="Overall-Framework-for-Structured-Prompt-Design"><a href="#Overall-Framework-for-Structured-Prompt-Design" class="headerlink" title="Overall Framework for Structured Prompt Design"></a>Overall Framework for Structured Prompt Design</h3><p>Building on the component definitions, we further established a comprehensive framework for structured prompt design, divided into the following five parts:</p>
<ul>
<li><strong>Requirement Anchoring:</strong> Accurately describing business requirements to ensure precise development targets.</li>
<li><strong>Structural Definition:</strong> Clarifying the dependencies and interactions among the modules required to implement functionality.</li>
<li><strong>Task Scheduling:</strong> Breaking down overall requirements into specific operational units and systematically defining each component to form a coherent workflow.</li>
<li><strong>Common Tasks:</strong> Standardizing high-frequency operations—such as data validation and exception handling—using template-driven solutions.</li>
<li><strong>Constraint Control:</strong> Setting up safety boundaries for the entire system by limiting the scope of component calls and references to prevent issues arising from unclear boundaries.</li>
</ul>
<p>Throughout this process, we adhere to two golden principles: first, the abstraction of the essence must take precedence over mere feature descriptions—only by clearly defining a component’s core responsibilities can we avoid superficial enumeration. Second, components should be regarded as logical units rather than merely fragments of code; similar to an excellent screenplay that emphasizes a character’s internal motivations rather than dictating every detail of an actor’s performance. Guided by these principles, the framework for structured prompt design has enabled our team to develop a systematic, rigorous, and highly efficient prompting system, thereby greatly enhancing overall development efficiency and code quality.</p>
<p>Structured_prompts_strategy.png</p>
<h2 id="Prompt-Engineering-Governance-Strategy-for-AI-Assets"><a href="#Prompt-Engineering-Governance-Strategy-for-AI-Assets" class="headerlink" title="Prompt Engineering: Governance Strategy for AI Assets"></a>Prompt Engineering: Governance Strategy for AI Assets</h2><p>Ensuring that prompts remain effective throughout the development process requires more than just crafting high-quality prompts—it necessitates a comprehensive governance strategy. We have divided prompt governance into multiple layers: the rule layer, the industry-specific abstract solution layer, the specific solution implementation layer, and the AI execution layer. Responsibilities are clearly delineated across these layers, with architects, technical leads, and developers each playing their part to maintain high standards and sustainability of our prompt assets.</p>
<p>prompts_governance_policy.png</p>
<p>In our pilot projects, we have already integrated logging rules into a predefined workflow, placing them at the rule layer to ensure that, prior to code generation, the necessary safety and quality standards are embedded via prompts. This approach not only ensures that the generated code adheres to logging standards but also builds a robust safety barrier for the entire system. As implementation continues, this governance strategy will be further refined and extended to a broader range of development scenarios, providing structured assurance for quality control and process management in software engineering.</p>
<h2 id="Analysis-of-a-Practical-Project-Example"><a href="#Analysis-of-a-Practical-Project-Example" class="headerlink" title="Analysis of a Practical Project Example"></a>Analysis of a Practical Project Example</h2><p>To illustrate the effectiveness of structured prompts more intuitively, let’s consider an API project for retrieving user permission information. This API is designed not only to support multi-criteria queries based on user ID, email, name, and role, but also to handle pagination, sorting, and the grouping and merging of data. In practice, we systematically organized and written the prompts according to the modules—requirements, structure, tasks, common tasks, and constraint controls. In the component definitions, we strictly adhered to the component description method and the core guiding principles of prompt construction. With this comprehensive framework, we successfully implemented an API that dynamically constructs query conditions based on multiple parameters and handles complex data grouping and merging.</p>
<p>Statistical results indicate that for the backend API module, the team employed 6 sets of prompts totaling 592 lines, which resulted in 1849 lines of generated code and modifications or creations of 37 files. Such a comprehensive practice covering complex business scenarios not only validates the feasibility of the structured prompt model but also significantly enhances delivery efficiency and code quality, heralding a revolutionary approach to traditional development methods.</p>
<p>Examples_of_project_practices.png</p>
<p>During the project, we also encountered real-world challenges and gathered valuable experiences. For teams new to this model, we found that there is no need to write prompts entirely from scratch—effective prompts can be extracted from existing code, thereby enabling rapid implementation and iterative refinement of the prompt system.</p>
<h2 id="Tips-and-Practical-Advice-for-Writing-Effective-Prompts"><a href="#Tips-and-Practical-Advice-for-Writing-Effective-Prompts" class="headerlink" title="Tips and Practical Advice for Writing Effective Prompts"></a>Tips and Practical Advice for Writing Effective Prompts</h2><p>Based on multiple projects, we have developed several strategies for writing high-quality prompts. First, when a solution already exists in current code, AI can be used to automatically parse and extract effective prompts, which can then be further refined. This approach not only saves time but also avoids the risks of starting from scratch. Second, when a solution is still in a developer’s mind, leveraging a reusable structured strategy and adjusting details according to the task at hand can quickly produce prompts that meet expectations. For those situations where the solution is not immediately clear, we recommend engaging in an open collaborative exploration with AI, gradually converging on ideas before using a structured template to generate initial prompts, followed by necessary manual refinement.</p>
<p>Our practical experience has also shown that it is crucial to avoid excessive abstraction when writing prompts. For simpler scenarios, there is often no need to develop an overly complex prompting system; direct conversational coding can be more efficient. Moreover, prompt writing should strike a balance between articulating the essence and detailing features—ensuring clarity in functionality and responsibilities without neglecting essential details. Ultimately, whether the aim is to generate excellent code via AI or to streamline subsequent review and modifications by developers, the final prompts must be both highly readable and practical, conveying the intended idea in clear, natural language.</p>
<p>Advice_of_practice.png</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In summary, prompt-driven development represents a novel software development model with unprecedented innovative potential. With the systematic design of structured prompts and rigorous governance strategies, we have successfully harnessed AI’s potential for code generation while significantly enhancing development efficiency and code quality. This approach has introduced a fundamentally new mode of thinking and working within our team.</p>
<p>Looking ahead, we will continue to monitor cutting-edge AI technologies and further refine our prompt design and governance strategies in even more complex scenarios. We anticipate that, propelled by ongoing exploration and practice by developers, the deep integration of human and AI efforts will usher in a new era in software development—driving the entire industry toward a more efficient and intelligent future. Through continuous iteration and optimization, we are confident that structured prompts will become a core technology in engineering practice, injecting endless innovative energy and competitive advantages into software development.</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><p>After this article was published externally, discussions ensued around the saying “features determine details, while essence defines boundaries” I noticed that there are varying interpretations regarding the basic definitions of “features” and “essence.” Therefore, I have included their fundamental definitions here to harmonize our understanding and help clarify the deeper meaning behind the statement.</p>
<p><strong>Features:</strong><br>Refers to the observable and describable specific attributes of a problem or requirement, including input&#x2F;output formats, constraints, interaction scenarios, technical parameters, and other explicit elements.<br><em>Core characteristics:</em> Quantifiable, verifiable, and concrete (readily observable).</p>
<p><strong>Essence:</strong><br>Refers to the fundamental conflict or core objective underlying a problem, which serves as the foundational logic determining the effectiveness of a solution.<br><em>Core characteristics:</em> Abstract, directional, and non-negotiable (the decisive factor that defines the solution).</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2024/12/11/guidelines-prompts-driven-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/guidelines-prompts-driven-development/" class="post-title-link" itemprop="url">Guidelines of Prompts Driven Development</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-11 17:00:00 / 修改时间：17:47:01" itemprop="dateCreated datePublished" datetime="2024-12-11T17:00:00+08:00">2024-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>This document outlines the structure and steps necessary to implement a business function within a software application, focusing on granularity, implementation steps, and the relationships between various components in the architecture.</p>
<h3 id="Business-Function-Overview"><a href="#Business-Function-Overview" class="headerlink" title="Business Function Overview"></a>Business Function Overview</h3><p>A business function refers to a specific operation or capability that a software application provides to fulfill business requirements. This can range from simple tasks like retrieving data to more complex operations like processing transactions.</p>
<h4 id="Granularity"><a href="#Granularity" class="headerlink" title="Granularity"></a>Granularity</h4><ul>
<li><strong>Minimum Granularity</strong>: One method</li>
<li><strong>Highest Granularity</strong>: One API</li>
</ul>
<h3 id="Implementation-Steps"><a href="#Implementation-Steps" class="headerlink" title="Implementation Steps"></a>Implementation Steps</h3><p>The implementation of a business function involves multiple layers, each with specific responsibilities. Below are the detailed steps required for implementing this function.</p>
<h4 id="Standard-Components"><a href="#Standard-Components" class="headerlink" title="Standard Components"></a>Standard Components</h4><ol>
<li><p><strong>Component Structure</strong></p>
<ul>
<li><strong>Class Name</strong>: Describe the class name</li>
<li><strong>Method Name</strong>: Describe the method name</li>
<li><strong>Responsibility</strong>: Describe the responsibilities of the component</li>
<li><strong>Request Body</strong>: Describe the request parameters (use ‘no parameters’ if there are none)</li>
<li><strong>Return Body</strong>: Returns data of type {Return Type}</li>
<li><strong>Endpoint</strong>: Describe the endpoint path</li>
<li><strong>Request Method</strong>: {GET&#x2F;POST&#x2F;PUT&#x2F;DELETE}</li>
<li><strong>Return Status Code</strong>: {HTTP status code}</li>
<li><strong>Attribute Definition</strong>: Define attributes as needed</li>
<li><strong>Static Members</strong>: List any static members if applicable</li>
<li><strong>Exceptions Handling</strong>: Describe how exceptions will be handled</li>
<li><strong>Elements</strong>: Identify any other necessary elements</li>
</ul>
</li>
<li><p><strong>Regular Example</strong></p>
<h5 id="Backend-Components"><a href="#Backend-Components" class="headerlink" title="Backend Components"></a>Backend Components</h5><ul>
<li><p><strong>Controller</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;Controller</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Endpoint: <code>/&#123;endpoint&#125;</code></li>
<li>Request Method: {GET&#x2F;POST&#x2F;PUT&#x2F;DELETE}</li>
<li>Request Body: {Describe the request parameters, write ‘no parameters’ if there are none}</li>
<li>Return Body: Returns data of type {Return Type}</li>
<li>Responsibility:<ul>
<li>Handling HTTP requests</li>
<li>Parameter verification</li>
<li>Call application services</li>
<li>Processing response</li>
</ul>
</li>
<li>Return Status Code: {HTTP status code}</li>
</ul>
</li>
<li><p><strong>Service</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;DomainService</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Responsibility:<ul>
<li>Implement core business logic</li>
<li>Maintain object status</li>
<li>Ensure business rules</li>
</ul>
</li>
<li>Request Body: {Description of Request Parameters}</li>
<li>Return Body: Returns data of type {Return Type}</li>
</ul>
</li>
<li><p><strong>Repository</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;Repository</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Responsibility:<ul>
<li>Implement data persistence</li>
<li>Implement data query</li>
<li>Database operation encapsulation</li>
</ul>
</li>
<li>Request Body: {Description of Request Parameters}</li>
<li>Return Body: Returns data of type {Return Type}</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Frontend Frameworks</strong><br>Utilize popular frameworks such as React, Angular, or Vue for building user interfaces that interact with the backend.</p>
</li>
</ol>
<h3 id="API-Implementation-Example-of-Hexagonal-architecture-No-architecture-modeling"><a href="#API-Implementation-Example-of-Hexagonal-architecture-No-architecture-modeling" class="headerlink" title="API Implementation Example of Hexagonal architecture(No architecture modeling)"></a>API Implementation Example of Hexagonal architecture(No architecture modeling)</h3><p>To implement an API that can update an entity (e.g., user information), follow these guidelines:</p>
<ul>
<li><p><strong>Controller Layer</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;Controller</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Endpoint: <code>/&#123;endpoint&#125;</code></li>
<li>Request Method: {GET&#x2F;POST&#x2F;PUT&#x2F;DELETE}</li>
<li>Request Body: {Describe the request parameters, write ‘no parameters’ if there are none}</li>
<li>Return Body: Returns data of type {Return Type}</li>
<li>Logic: Call the corresponding method of the Application layer to obtain data.</li>
<li>Return Status Code: {HTTP status code}</li>
</ul>
</li>
<li><p><strong>Application Service Layer</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;ApplicationService</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Logic: Call relevant methods of the Query layer or Domain layer.</li>
<li>Request Body: {Description of Request Parameters}</li>
<li>Return Body: Returns data of type {Return Type}</li>
<li>Exception Handling Required.</li>
</ul>
</li>
<li><p><strong>Query Layer</strong><br>This layer is responsible for obtaining resources.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Name: `&#123;EntityName&#125;Query`</span><br><span class="line">Method Name: `&#123;methodName&#125;`</span><br><span class="line">Logic: Call infrastructure-related methods.</span><br><span class="line">Request Body: &#123;Description of Request Parameters&#125;</span><br><span class="line">Return Body: Returns data of type &#123;Return Type&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Domain Layer</strong><br>Implements business logic details.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Name:`&#123;EntityName&#125;DomainService`</span><br><span class="line">Method Name:`&#123;methodName&#125;`</span><br><span class="line">Logic: Call relevant methods of the Infrastructure layer.</span><br><span class="line">Request Body:&#123;Description of Request Parameters&#125;</span><br><span class="line">Return Body:&#123;Returns data of type &#123;Return Type&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Repository Layer</strong><br>Handles database interactions.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Name:`&#123;EntityName&#125;Repository`</span><br><span class="line">Method Name:`&#123;methodName&#125;`</span><br><span class="line">Logic: Call relevant methods of the database.</span><br><span class="line">Request Body:&#123;Description of Request Parameters&#125;</span><br><span class="line">Return Body:&#123;Returns data of type &#123;Return Type&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Testing-Strategy"><a href="#Testing-Strategy" class="headerlink" title="Testing Strategy"></a>Testing Strategy</h3><p>Generate unit tests and integration tests based on the methods defined in each layer. Use tools and frameworks appropriate for your programming environment to facilitate this process.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Implementing a business function requires careful planning and adherence to structured guidelines across various layers of an application. By following these guidelines, developers can ensure that their applications are robust, maintainable, and scalable.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2024/11/15/refactoring-with-cursor-en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/15/refactoring-with-cursor-en/" class="post-title-link" itemprop="url">Building Prompts Using the ReAct Framework for Efficient Code Refactoring with Cursor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-15 19:00:00" itemprop="dateCreated datePublished" datetime="2024-11-15T19:00:00+08:00">2024-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-09 12:48:50" itemprop="dateModified" datetime="2025-01-09T12:48:50+08:00">2025-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Introduction-A-Journey-from-Simple-to-Complex-AI-Programming"><a href="#Introduction-A-Journey-from-Simple-to-Complex-AI-Programming" class="headerlink" title="Introduction: A Journey from Simple to Complex AI Programming"></a>Introduction: A Journey from Simple to Complex AI Programming</h2><p>In my previous blog, I enthusiastically shared how I used Cursor to achieve a 0 to 1 implementation of an AI tool in just half a day. At that time, I felt like a child who had just learned to ride a bicycle, filled with excitement about this “new toy.” However, I soon realized that this was just the tip of the iceberg. While code generation is thrilling, the challenges we face in actual development are far more complex.<br>This realization propelled me into a deeper exploration, particularly in the area of code refactoring. I discovered that Cursor exhibited surprising potential. When I provided it with some refactoring instructions, it not only understood my intentions but also restructured the code as expected, and at an astonishing speed. This made me dream: if I could apply this skill in daily development, I could be leisurely “fishing” while others were still buried in refactoring!</p>
<h2 id="The-Reality-Check-The-Dilemma-of-Refactoring-Complex-Projects"><a href="#The-Reality-Check-The-Dilemma-of-Refactoring-Complex-Projects" class="headerlink" title="The Reality Check: The Dilemma of Refactoring Complex Projects"></a>The Reality Check: The Dilemma of Refactoring Complex Projects</h2><p>However, reality often delivers a harsh blow. When I confidently applied this straightforward refactoring approach to real projects, I quickly hit a wall. The complexity of real projects far exceeded that of simple AI tool code projects, and simple prompts felt like trying to use a toothpick to move an elephant.</p>
<p><strong>Main Issues Encountered:</strong></p>
<ol>
<li><strong>Uncontrolled Scope of Changes</strong>: Each refactor felt like a random walk without a map.</li>
<li><strong>Chaotic Refactoring Strategies</strong>: Relying entirely on large models to select refactoring strategies was akin to handing the steering wheel to a blindfolded driver.</li>
<li><strong>Contextual Understanding Barriers</strong>: Even with @Codebase, Cursor seemed oblivious to the overall project context, leading to aimless refactoring.</li>
<li><strong>Code Review Burden</strong>: Each change required meticulous review; otherwise, it felt like dancing on the edge of a knife.</li>
<li><strong>Vicious Cycle</strong>: The more I refactored, the messier it became, ultimately forcing me to start over and fall into a “start over - fail again” loop.</li>
</ol>
<p><strong>Root Cause Analysis:</strong><br>After deep reflection, several core reasons emerged:</p>
<ol>
<li><strong>Excessive Logical Complexity:</strong> Real projects often contain intricate business logic and conditional judgments.</li>
<li><strong>Lack of Framework Knowledge:</strong> There was insufficient onboarding for AI regarding frameworks.</li>
<li><strong>Diversity in Coding Styles:</strong> Variations in coding styles among different developers posed challenges.</li>
<li><strong>Overwhelming Contextual Burden:</strong> Too many interrelated codes formed a complex web of dependencies.</li>
<li><strong>Unpredictable Behavior:</strong> It was impossible to accurately anticipate the AI’s next actions.</li>
</ol>
<h2 id="Human-vs-Machine-Differences-in-Refactoring-Mindsets"><a href="#Human-vs-Machine-Differences-in-Refactoring-Mindsets" class="headerlink" title="Human vs. Machine: Differences in Refactoring Mindsets"></a>Human vs. Machine: Differences in Refactoring Mindsets</h2><p>To find a breakthrough, I pondered why human developers could navigate refactoring relatively smoothly while AI frequently stumbled.</p>
<p><strong>Human Developer’s Refactoring Approach:</strong></p>
<ol>
<li><strong>Systematic Analysis:</strong> Identifying and eliminating code smells first to enhance readability and scalability.</li>
<li><strong>Object-Oriented Optimization:</strong> Refactoring based on best practices in object-oriented design.</li>
<li><strong>Architectural Adjustments:</strong> Reorganizing code into appropriate hierarchical structures.</li>
<li><strong>Testing Validation:</strong> Ensuring that the refactored code still meets expected behaviors.<br><strong>AI’s Refactoring Approach:</strong> It resembles a mechanical worker simply repeating the action of “modifying code,” lacking the systematic thinking and strategic planning we expect.</li>
</ol>
<h2 id="Inspiration-Strikes-Insights-from-the-ReAct-Framework"><a href="#Inspiration-Strikes-Insights-from-the-ReAct-Framework" class="headerlink" title="Inspiration Strikes: Insights from the ReAct Framework"></a>Inspiration Strikes: Insights from the ReAct Framework</h2><p>In my quest for solutions, I encountered Agent and ReAct along with Chain-of-Thought (CoT), which sparked an idea. If we could enable AI to think like humans and reason in ways we expect, could we overcome the current challenges?</p>
<h3 id="Overview-of-the-ReAct-Framework"><a href="#Overview-of-the-ReAct-Framework" class="headerlink" title="Overview of the ReAct Framework"></a>Overview of the ReAct Framework</h3><p>The ReAct framework was proposed by Shunyu Yao et al. in 2022 as a method that combines reasoning and action to enhance the performance of large language models (LLMs). This framework allows LLMs to alternately generate <strong>reasoning traces</strong> and <strong>task-specific operations</strong>, enabling models to induce, track, and update operational plans effectively while handling exceptions.</p>
<ul>
<li><strong>Interaction with External Tools:</strong> The ReAct framework enables LLMs to interact with external knowledge bases or environments for additional information, providing more reliable responses.</li>
<li><strong>Performance Improvement:</strong> Research shows that ReAct outperforms several advanced baseline models in language and decision-making tasks while enhancing LLMs’ interpretability and trustworthiness.</li>
<li><strong>Integration with Chain-of-Thought (CoT):</strong> Combining ReAct with CoT allows for leveraging both internal knowledge and external information during reasoning for optimal results.</li>
</ul>
<h2 id="Practice-Constructing-Refactoring-Specific-Prompts"><a href="#Practice-Constructing-Refactoring-Specific-Prompts" class="headerlink" title="Practice: Constructing Refactoring-Specific Prompts"></a>Practice: Constructing Refactoring-Specific Prompts</h2><p><strong>Designing Refactoring Steps:</strong></p>
<ol>
<li><strong>Basic Cleanup:</strong> Identify and address fundamental code smells.</li>
<li><strong>Object-Oriented Optimization:</strong> Apply best practices in object-oriented design.</li>
<li><strong>Architectural Adjustments:</strong> Restructure code according to hexagonal architecture standards.</li>
<li><strong>Error Fixing:</strong> Address obvious compilation errors.</li>
<li><strong>Manual Review:</strong> Supplement detail optimization.</li>
<li><strong>Test Fixes:</strong> Ensure all test cases pass.</li>
</ol>
<p><img src="/../images/new_refactoring_processing.jpg" alt="new_refactoring_processing.jpg"></p>
<p><strong>Designing Refactoring Prompt Template:</strong></p>
<ol>
<li><strong>Context Explanation:</strong> Provide architectural standards and best practice guidelines.</li>
<li><strong>Thinking Steps:</strong> Guide AI through systematic analysis.</li>
<li><strong>Observation Records:</strong> Document identified issues. </li>
<li><strong>Action Guidelines:</strong> Clearly outline specific refactoring steps.</li>
</ol>
<p><img src="/../images/prompt_design.jpg" alt="prompt_design.jpg"></p>
<p>Based on insights from ReAct and CoT, I designed a prompt for DDD refactoring on the current project (covering the first three steps):<br><strong>Prompt for Refactoring</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Context: In hexagonal architecture DDD implementation patterns, there are best practices and experiences regarding the design and implementation of Application Service, Domain Service, Query, and Port. Here are summarized experiences and suitable refactoring prompts:</span><br><span class="line"><span class="bullet">1.</span> Application Service</span><br><span class="line"><span class="bullet">    -</span> Primarily responsible for use case orchestration and transaction management without business logic; instead calls Domain Service for specific operations.</span><br><span class="line"><span class="bullet">2.</span> Domain Service</span><br><span class="line"><span class="bullet">    -</span> Contains core business logic handling complex business rules and operations as part of the domain model.</span><br><span class="line"><span class="bullet">3.</span> Port</span><br><span class="line"><span class="bullet">    -</span> Defines interfaces between applications and external systems, including definitions of Repository interfaces within inbound and outbound packages.</span><br><span class="line"></span><br><span class="line">Based on this context, please refer to @AcademyCourseDomainService.java for refactoring the current file; modifications involving @EnrollmentApplicationService.java can also be made. Use the ReAct framework following these thinking steps to analyze, observe, execute, and ultimately complete code refactoring.</span><br><span class="line">Thought-1: Are there any obvious code smells?</span><br><span class="line">Observation-1: There is a code smell: xxxx</span><br><span class="line">Action-1: Refactor using best practices corresponding to this code smell.</span><br><span class="line"></span><br><span class="line">Thought-2: Are there any particularly concerning code smells regarding object-oriented principles such as single responsibility principle (SRP), open/closed principle (OCP), Liskov substitution principle (LSP), dependency inversion principle (DIP), and interface segregation principle (ISP)?</span><br><span class="line">Observation-2: Several areas xxxx do not comply with SRP.</span><br><span class="line">Action-2: Understand best practices of SRP and perform code refactoring accordingly.</span><br><span class="line"></span><br><span class="line">Thought-3: What layer does the current file belong to? What responsibilities must be adhered to?</span><br><span class="line">Observation-3: The current file is a Domain service; some implementations xxxx do not align with domain service responsibilities.</span><br><span class="line">Action-3: Refactor these implementations based on Domain service responsibilities by analyzing which layer&#x27;s duties they belong to and relocating them accordingly.</span><br></pre></td></tr></table></figure>
<p>Output of Cursor composer:<br><img src="/../images/prompt_result_1.png" alt="prompt_result_1.png"><br><img src="/../images/prompt_result_2.png" alt="prompt_result_2.png"></p>
<h2 id="Experimental-Results-and-Lessons-Learned"><a href="#Experimental-Results-and-Lessons-Learned" class="headerlink" title="Experimental Results and Lessons Learned"></a>Experimental Results and Lessons Learned</h2><p>Through multiple experiments, this ReAct-based prompt writing method demonstrated significant advantages:</p>
<ol>
<li><strong>Higher Result Accuracy:</strong> This refactoring method achieved expected results quickly within two or three interactions. The combination of ReAct and CoT allowed models to integrate information effectively during reasoning processes, reducing errors and uncertainties significantly.</li>
<li><strong>Goal-Oriented Thinking Process:</strong> After adopting the ReAct framework, the model’s reasoning direction aligned more closely with user expectations rather than being influenced by hallucinations (i.e., generating false information). By introducing additional information sources (observational steps provide necessary information), models could verify and update their reasoning paths in real time.</li>
<li><strong>Visualized Thinking and Modification Process:</strong> In Cursor’s composer mode, users can clearly see intermediate thought processes and modifications. This transparency enables developers to track each modification step better understand how models arrive at conclusions.</li>
</ol>
<h3 id="Key-Factors-for-Improved-Outcomes"><a href="#Key-Factors-for-Improved-Outcomes" class="headerlink" title="Key Factors for Improved Outcomes:"></a>Key Factors for Improved Outcomes:</h3><ol>
<li><strong>Clear Boundaries:</strong> Context limits AI’s behavioral scope.</li>
<li><strong>Defined Steps:</strong> Guides AI through predetermined thought processes during refactoring.</li>
<li><strong>Feedback Loop Closure:</strong> Each step has clear observation and action guidelines.</li>
</ol>
<h3 id="Shift-in-Mindset"><a href="#Shift-in-Mindset" class="headerlink" title="Shift in Mindset:"></a>Shift in Mindset:</h3><p>This process made me realize that using AI effectively hinges on shifting our mindset from “problem-oriented” to “guided collaboration.” Our roles should be:</p>
<ul>
<li>Humans handle analysis and planning,</li>
<li>AI executes specific details,</li>
<li>Establish bridges through well-designed prompts.</li>
</ul>
<h2 id="Conclusion-A-New-Paradigm-for-AI-Coding-Assistants"><a href="#Conclusion-A-New-Paradigm-for-AI-Coding-Assistants" class="headerlink" title="Conclusion: A New Paradigm for AI Coding Assistants"></a>Conclusion: A New Paradigm for AI Coding Assistants</h2><p>This exploration not only helped me tackle the challenges of code refactoring but also imparted an important lesson: AI is not omnipotent; however, through proper guidance, it can become a powerful assistant that amplifies our capabilities. When we learn to interact with AI as “coaches” rather than “questioners,” we often achieve better results.<br>Of course, this brings new demands; understanding best practices and methodologies becomes essential when collaborating with AI so that we can guide it effectively towards completing tasks correctly.<br>This shift in thinking allows us to better leverage human creativity alongside AI execution capabilities—enhancing both code quality and development efficiency (ideally saving time should promote improved code quality rather than merely pursuing high output; otherwise, we risk falling into another quagmire where chasing output neglects quality). Balancing efficiency with quality is crucial; by emphasizing readability, maintainability, and sound best practices in our codebase, we can accelerate development while ensuring long-term software health and stability.<br>In future endeavors, this human-machine collaborative model may emerge as a new paradigm in software development.</p>
<h2 id="Final-Note-Prompt-Sharing"><a href="#Final-Note-Prompt-Sharing" class="headerlink" title="Final Note: Prompt Sharing"></a>Final Note: Prompt Sharing</h2><p>Through practice, we’ve developed a prompt template specifically targeting code smell refactoring. If you’re interested in addressing code smells in your projects, feel free to try out this Prompt Template available on our site tailored for developers seeking efficient prompts that enhance their experience using Cursor for refactoring—especially aimed at those looking to optimize their refactoring processes through AI assistance.<br>This prompt template site aims at providing practical resources designed for developers looking for actionable templates that enhance their experience using Cursor for refactoring tasks while minimizing potential hallucinations during such processes.<br>We encourage everyone using Cursor or other AI coding assistance tools to share effective prompts within this repository. Together we can build a practical collection of refactoring prompts that enhance daily efficiency and code quality during development tasks!</p>
<p>Thank you all for reading!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wiilie Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wiilie Zhang</span>
</div>
  <div class="powered-by">
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
