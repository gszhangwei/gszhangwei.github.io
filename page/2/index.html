<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gszhangwei.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Willie&#39;s Blog">
<meta property="og:url" content="hhttps://gszhangwei.github.io/page/2/index.html">
<meta property="og:site_name" content="Willie&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wiilie Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="hhttps://gszhangwei.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Willie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Willie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/02/27/prompts-driven-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/prompts-driven-development/" class="post-title-link" itemprop="url">结构化提示词驱动开发实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 17:00:00" itemprop="dateCreated datePublished" datetime="2025-02-27T17:00:00+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-28 16:48:41" itemprop="dateModified" datetime="2025-02-28T16:48:41+08:00">2025-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上周六参加了公司组织的关于AI实践的对外直播，我分享的内容是《结构化提示词驱动开发实践》。现在将其记录成一篇博客，在此与大家分享我们团队在提示词驱动开发领域的一些实践与思考。随着大语言模型的不断成熟，我们逐步认识到，如何高效运用结构化提示词，引导AI生成高质量代码，已成为提升软件开发效率与质量的关键所在。本文将围绕“<strong>结构化提示词驱动开发</strong>”这一主题，从设计理念、实践路径到治理策略，全面解析提示词在软件开发中如何落地应用，并以数据与实例展示其显著成效。</p>
<h2 id="解锁解决方案：克服关键挑战"><a href="#解锁解决方案：克服关键挑战" class="headerlink" title="解锁解决方案：克服关键挑战"></a>解锁解决方案：克服关键挑战</h2><p>在早期的AI辅助开发过程中，我们曾经深刻体会到传统开发模式的诸多局限。常规的对话式代码生成往往存在如下问题：生成的代码可用性不足、质量参差不齐，以至于后续大量人工返工成为常态；同时，对话式生成方案不易形成固化、可复用的工程产物，制约了AI在工程级项目中的大规模应用。数据显示，AI生成代码的采纳率普遍低于50%，而代码质量的波动也使得实际交付面临诸多风险。</p>
<p>正因如此，我们开始思考：如果能够突破这些障碍，充分激发AI在交付过程中的潜能，那么软件开发的方式将会迎来怎样的变革？经过反复探索与实践，我们认为解决这一问题需要三大能力作支撑：</p>
<ul>
<li>第一是迅速分析问题，并精准识别出根本原因，从而为后续提供有效解决方案；</li>
<li>第二是依托严谨的工程实践，通过标准流程来保障代码质量；</li>
<li>第三也是最为关键的，即通过使用结构化提示词，让AI生成的代码具备可解释性、可追溯性和高采纳率。<br><img src="/../images/Challenge_and_Solution.png" alt="Challenge_and_Solution.png"><br>正是这三大支柱构成了我们突破传统模式、推动AI赋能开发的核心思路，也为后续实践提供了坚实的理论基础和指导方向。</li>
</ul>
<h2 id="试点项目探索与验证"><a href="#试点项目探索与验证" class="headerlink" title="试点项目探索与验证"></a>试点项目探索与验证</h2><p>为了验证这一方法论的可行性，我们开展了一系列试点项目，尽管具体业务细节不便透露，但整体项目任务包括了前端服务的初始化、基础设施及持续集成（CI）的搭建、前后端代码与测试的新编写，以及现有前端系统的重构。项目交付后，通过对数据的详细采集与对比分析，我们获得了非常振奋的成果。</p>
<p>例如，在从零开始构建系统的任务中，传统开发模式需要消耗约19人天，而采用结构化提示词模式后，仅耗时7人天，且代码采纳率高达95%，这不仅大幅缩短了开发周期，也使得生产力实现近3倍的提升。而针对遗留系统的需求响应，开发时间则由原先的5人天缩短至3人天，生产效率提升约1.7倍。此外，我们还观察到，通过这种模式，代码重复率显著降低，单元测试覆盖率由65%增加至96%。这些数据充分说明，结构化提示词不仅提高了交付效率，更在实际工程中提升了代码质量和系统稳定性。<br><img src="/../images/Background_of_Project.png" alt="Background_of_Project.png"><br>数据背后的意义在于，我们成功为AI赋能软件开发找到了一条有效路径，这种路径打破了传统开发方式的局限，将原本模糊难控的生成过程转化为可管理、可复制的工程实践，为整个团队带来了崭新的开发体验和惊人的效率提升。</p>
<p>让我们先探讨如何在软件开发领域中构建有效提示词，再逐步回顾我们所做的具体实践。</p>
<h2 id="结构化提示词设计框架"><a href="#结构化提示词设计框架" class="headerlink" title="结构化提示词设计框架"></a>结构化提示词设计框架</h2><h3 id="如何有效构建提示词？"><a href="#如何有效构建提示词？" class="headerlink" title="如何有效构建提示词？"></a>如何有效构建提示词？</h3><p>在软件开发领域利用自然语言驱动AI生成代码过程中，一个根本性矛盾一直存在：人类思维具有天然的发散性，而AI执行指令则要求极高的结构化和精确性。传统提示词设计容易陷入两种误区：一方面，开发者可能过分依赖表面化描述，如直接要求“生成800字带小标题的营销文案”，这种方式虽然直白，但往往流于形式；另一方面，则可能陷入抽象概念的模糊描述，让AI自行揣测具体意图，从而导致输出偏离预期目标。</p>
<p>为突破这一矛盾，我们强调思维方式的跃迁，即要从简单的特征描述（例如颜色、形状等外在属性）转向对事物本质的抽象提炼（例如功能内核与运行机制）。只有当我们首先明确定义对象的核心功能与本质特性，再辅以具体细节描述，才能为AI提供一条唯一且明确的生成路径，最大程度降低AI的幻觉。例如，在需要生成一个“白色冰箱”的场景中（假设我们并不知道冰箱这一名词概念），如果仅以“生成一个四方形白色物体，下方有四个小轮子”进行描述，可能误导AI产生与冰箱无关的对象；而若从本质出发，先定义“维持低温环境”这一核心功能，然后再补充其它特征，便能精准锁定冰箱这一概念，同时也为其它如冷库、冷链车留下一定扩展空间。正如我们所倡导的，“特征决定细节，本质决定边界”，只有先明晰本质，后注重具体细节，才能确保生成结果符合预期。<br><img src="/../images/Construct_prompts_effectively.png" alt="Construct_prompts_effectively.png"></p>
<h3 id="组件描述法在提示词构建中的实践"><a href="#组件描述法在提示词构建中的实践" class="headerlink" title="组件描述法在提示词构建中的实践"></a>组件描述法在提示词构建中的实践</h3><p>基于上述理念，在构建提示词时我们引入了组件描述法。以后端开发为例，我们为每个组件设计了涵盖类名、方法名、异常处理等在内的多达10个标准化维度。通过这种方法，每个组件不仅能够明确界定其功能边界，也实现了逻辑上的严谨封装。需要说明的是，这里的“组件”概念与传统开发框架中的概念有所不同，它指的是构成结构化提示词的基本单元，是对功能职责和实现过程的细致拆解。<br><img src="/../images/Component_Description.png" alt="Component_Description.png"><br>组件描述法的引入，使得每个提示词单元既自成体系又相互衔接，在明确各自核心职责的同时，通过精准定义其属性和操作范围，有效避免了各组件之间的混淆和重叠，保障了整体提示词的严密性和生成代码的一致性。这样的设计不仅极大增强了系统的可维护性，也为处理复杂业务场景提供了有力支撑。</p>
<h3 id="结构化Prompt设计整体框架"><a href="#结构化Prompt设计整体框架" class="headerlink" title="结构化Prompt设计整体框架"></a>结构化Prompt设计整体框架</h3><p>在组件定义的基础上，我们进一步构建了完整的结构化Prompt设计框架，该框架总体分为以下五个部分：</p>
<p>需求锚定阶段要求我们准确描述业务需求，确保开发目标的精准定位；结构定义阶段则负责明确实现功能所需模块之间的依赖关系和相互作用；任务编排阶段将整体需求拆解成具体操作单元，通过逐一定义各组件来形成连续的工作流；在通用任务阶段，我们对数据校验、异常处理等高频操作进行标准化处理，以模板化的方式复用解决方案；最后，约束控制阶段为整个系统设置安全围栏，限定组件调用的范围和引用关系，防止因边界不清引发的潜在问题。</p>
<p>在此过程中，我们始终坚持两个黄金准则：首先，本质抽象必须优先于特征描述，只有清晰定义组件的核心职责，才能避免陷入形式化穷举的困境；其次，组件应被视为逻辑单元，而非仅仅是代码片段，就如一部优秀剧本强调刻画人物内在动机，而非干涉演员细微表现。正是在这两个准则的指引下，结构化Prompt设计框架为团队构建了一套系统、严谨且高效的提示词应用体系，极大地提升了整体开发效率和代码质量。<br><img src="/../images/Structured_prompts_strategy.png" alt="Structured_prompts_strategy.png"></p>
<h2 id="提示词工程：AI资产的治理策略"><a href="#提示词工程：AI资产的治理策略" class="headerlink" title="提示词工程：AI资产的治理策略"></a>提示词工程：AI资产的治理策略</h2><p>要确保提示词在长期开发过程中的持续有效性，仅仅构建高质量提示词是不够的，还需要建立一套完善的治理策略。我们将提示词治理分为多个层级：规则层、行业垂直方案抽象层、解决方案具体实现层以及AI执行层。各层级之间分工明确，架构师、技术负责人与开发工程师各自履行职责，共同维护提示词资产的高标准和可持续性。<br><img src="/../images/prompts_governance_policy.png" alt="prompts_governance_policy.png"><br>目前，在试点项目中，我们已经通过预定义工作流引入日志规则，将其置于规则层，确保在代码生成前通过提示词预先注入必要的安全和质量标准。这不仅使得生成代码符合日志规范，同时也为整个系统构建起一道坚固的防护屏障。随着实施的不断推进，这一治理策略将逐步完善并推广到更广泛的开发场景中，为软件工程在质量控制和流程管理上提供制度化保障。</p>
<h2 id="项目实践实例解析"><a href="#项目实践实例解析" class="headerlink" title="项目实践实例解析"></a>项目实践实例解析</h2><p>为了更直观地展示结构化提示词的应用效果，我们以一个获取用户权限信息的API项目为例进行说明。该API不仅需支持根据用户ID、邮箱、姓名及角色进行多条件查询，还要求具备分页、排序以及对数据进行分组合并的功能。在实际开发中，我们依照需求、结构、任务、通用任务与约束控制等模块，系统地组织和编写提示词，同时在组件定义中严格遵循组件描述法和构建提示词的核心指导思想。依托这一完备的体系，我们最终实现了一个能够根据多参数动态构建查询条件，并对数据进行复杂分组与合并操作的API。</p>
<p>统计结果显示，在后端实现API模块，团队共使用6组提示词，总行数达592行，最终生成代码1849行，涉及37个文件的新增或修改。如此覆盖复杂业务场景的实践成果，不仅充分验证了结构化提示词模式的可行性，也大大提升了交付效率和代码质量，为传统开发模式带来了全新的变革思路。<br><img src="/../images/Examples_of_project_practices.png" alt="Examples_of_project_practices.png"><br>在项目推进过程中，我们也直面了一些实际问题，并据此积累了宝贵经验。尤其对于初次接触该模式的团队而言，我们发现并不需要从零开始书写提示词，而可以从现有代码中提炼有效提示，从而逐步优化和完善提示体系，实现快速落地和迭代。</p>
<h2 id="有效撰写提示词的技巧与实战建议"><a href="#有效撰写提示词的技巧与实战建议" class="headerlink" title="有效撰写提示词的技巧与实战建议"></a>有效撰写提示词的技巧与实战建议</h2><p>通过多次项目实践，我们总结出如下几种撰写高质量提示词的有效策略。首先，当解决方案已经存在于现有代码中时，可以利用AI自动解析代码，提取出有效提示词，并在此基础上进行优化，这种做法既节约了时间，也避免了从零开始的风险。其次，当解决方案尚存于开发者脑海时，借助可复用的结构化策略，并根据不同任务灵活调整细节，能迅速形成符合预期的提示词。对于那些暂时无解的情况，我们建议先与AI展开开放性协作探索，通过不断收敛思路后，借助结构化模板生成初步提示词，再由开发者进行必要的人工微调和确认。</p>
<p>在实践中我们还发现，写作提示词时应特别注意避免过度抽象。对于简单场景，往往无需构建复杂的提示体系，此时采用直接的对话式编程反而更为高效。此外，提示词的撰写要做到本质与特征兼顾——既要确保功能和职责的清晰表述，又不能忽略细节描述的重要性。最关键的是，无论是为了让AI生成优秀代码，还是为了便于开发者后期审核修正，最终形成的提示词都必须具备良好的可读性和实用性，能够以清晰自然的语言传达预期意图。<br><img src="/../images/Advice_of_practice.png" alt="Advice_of_practice.png"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总体而言，提示词驱动开发作为一种全新的软件开发模式，展现出前所未有的创新潜力。凭借结构化提示词的系统设计与严格治理策略，我们不仅成功激发了AI在代码生成中的潜能，还显著提升了开发效率和代码质量，为我们团队引入了全新的思考方式和工作模式。</p>
<p>展望未来，我们将持续关注AI技术的前沿动态，并在更为复杂的实际场景下不断完善提示词设计与治理体系。我们期待，在广大开发者不断探索和实践的推动下，人与AI的深度融合能够开启软件开发的新纪元，共同推动整个行业迈向更高效、更智能的未来。通过不断迭代与优化，相信结构化提示词必将成为工程实践中的一项核心技术，为软件开发注入源源不断的创新动力和竞争优势。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>这篇文章在外部发表后，大家围绕“特征决定细节，本质决定边界”展开了一些讨论。但我发现，大家对“特征”和“本质”的基本定义可能存在不同理解。为此，我在这里补充了它们的基本定义，以便统一认知，从而帮助大家更好地理解这句话的深层含义。<br>特征（Features）：指问题或需求中可观测、可描述的具体属性，包括输入输出形式、约束条件、交互场景、技术参数等显性要素。核心特点：可量化，可验证，具象化（容易观察到的）。<br>本质（Essence）：指问题背后需要解决的根本矛盾或核心目标，是决定解决方案有效性的底层逻辑。核心特点：抽象性，方向性，不可妥协性（那个能够决定成为它的东西）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/02/27/prompt-driven-development-en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/prompt-driven-development-en/" class="post-title-link" itemprop="url">Structured prompts driven development</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 17:00:00" itemprop="dateCreated datePublished" datetime="2025-02-27T17:00:00+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-03 12:07:28" itemprop="dateModified" datetime="2025-03-03T12:07:28+08:00">2025-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Recently, I took part in an external livestream hosted by our company in China, where I presented on the topic of ‘Structured Prompt-Driven Development Practice. I am now recording this experience as a blog post to share some of our team’s practices and reflections on prompt-driven development. As large language models continue to mature, we are increasingly realizing that efficiently leveraging structured prompts to guide AI in generating high-quality code is key to improving both software development efficiency and quality. This article, centered on <strong>Structured Prompt-Driven Development</strong>, comprehensively analyzes how prompts can be applied in software development—from design philosophy and practical implementation to governance strategies—supporting our discussion with data and practical examples.</p>
<h2 id="Unlocking-Solutions-Overcoming-Key-Challenges"><a href="#Unlocking-Solutions-Overcoming-Key-Challenges" class="headerlink" title="Unlocking Solutions: Overcoming Key Challenges"></a>Unlocking Solutions: Overcoming Key Challenges</h2><p>In the early stages of AI-assisted development, we experienced firsthand the many limitations of conventional development models. The typical conversational code generation approach often suffers from several issues: the generated code frequently lacks usability and exhibits uneven quality, leading to extensive manual rework; moreover, conversational generation methods do not readily produce fixed, reusable engineering deliverables, which limits the large-scale application of AI in enterprise-level projects. Data shows that the adoption rate of AI-generated code is generally below 50%, and the fluctuations in code quality pose significant risks for actual delivery.</p>
<p>This led us to ponder: if we could overcome these obstacles and fully harness the potential of AI during the delivery process, how might software development transform? After extensive exploration and practical trials, we determined that addressing these challenges requires three core capabilities:</p>
<ul>
<li>The ability to quickly analyze problems and accurately identify root causes, thereby providing effective subsequent solutions.</li>
<li>A reliance on rigorous engineering practices that ensure code quality through standardized processes.</li>
<li>Most critically, employing structured prompts that enable AI to generate code which is interpretable, traceable, and highly adoptable.</li>
</ul>
<p>Challenge_and_Solution.png</p>
<p>These three pillars form the core of our breakthrough from traditional methodologies and drive our AI-empowered development approach, providing a solid theoretical foundation and clear guidance for our subsequent practices.</p>
<h2 id="Pilot-Project-Exploration-and-Validation"><a href="#Pilot-Project-Exploration-and-Validation" class="headerlink" title="Pilot Project Exploration and Validation"></a>Pilot Project Exploration and Validation</h2><p>To validate the feasibility of our methodology, we conducted a series of pilot projects. Although specific business details cannot be disclosed, the overall project tasks included initializing new frontend services, setting up infrastructure and continuous integration (CI), writing new backend and frontend code and tests, and refactoring existing frontend systems. After project delivery, detailed data collection and comparative analysis yielded remarkably encouraging results.</p>
<p>For instance, in a system built from scratch, the traditional development model required approximately 19 man-days, whereas the structured prompt-driven approach took only 7 man-days—with a code adoption rate as high as 95%. This not only reduced the development cycle dramatically but also nearly tripled productivity. Similarly, for legacy system requirements, development time was reduced from 5 to 3 man-days, representing about a 1.7-times improvement in efficiency. Additionally, we observed a significant reduction in code duplication and an increase in unit test coverage from 65% to 96%. These results clearly demonstrate that structured prompts not only improve delivery efficiency but also enhance code quality and overall system stability.</p>
<p>Background_of_Project.png</p>
<p>The significance of these results is that we have successfully discovered an effective path to harness AI for software development. This approach breaks through the limitations of traditional methods by transforming the inherently ambiguous generation process into a manageable, replicable engineering practice—bringing our team a brand-new development experience along with astonishing efficiency gains.</p>
<p>Let’s first explore how to construct effective prompts in the realm of software development, and then review our specific practices.</p>
<h2 id="Structured-Prompt-Design-Framework"><a href="#Structured-Prompt-Design-Framework" class="headerlink" title="Structured Prompt Design Framework"></a>Structured Prompt Design Framework</h2><h3 id="How-to-Construct-Effective-Prompts"><a href="#How-to-Construct-Effective-Prompts" class="headerlink" title="How to Construct Effective Prompts?"></a>How to Construct Effective Prompts?</h3><p>In software development, using natural language to drive AI code generation presents a fundamental contradiction: human thinking is inherently divergent, while AI requires highly structured and precise instructions. Traditional prompt design can fall into two pitfalls. On one hand, developers might overly rely on superficial descriptions—such as simply asking “Generate an 800-word marketing copy with subheadings.” Although straightforward, this approach often turns out to be formulaic. On the other hand, overly abstract descriptions leave too much room for interpretation, causing AI to stray from the intended target.</p>
<p>To overcome this contradiction, we emphasize a shift in thinking—from merely describing features (like color or shape) to abstracting the essence of an object (its core functionality and operational mechanism). Only by first clearly defining an object’s core function and essential characteristics, and then supplementing that with specific details, can we provide AI with a unique, unambiguous generation path that minimizes “hallucinations.” For example, consider a scenario where we need to generate a “white refrigerator” (assuming we are not familiar with the abstract concept of a refrigerator). If we only describe it as “a square white object with four small wheels at the bottom,” AI might produce something unrelated to a refrigerator. However, if we begin by defining its essential function as “maintaining a low-temperature environment” and then add additional feature details, we can accurately target the concept of a refrigerator while still leaving room for related ideas such as cold storage or refrigerated trucks. As we advocate, “features determine details, while essence defines boundaries.” Only by clearly articulating the essence first and then supplementing with specifics can we ensure that the generated outcome aligns with our expectations.</p>
<p>Construct_prompts_effectively.png</p>
<h3 id="Application-of-the-Component-Description-Method-in-Prompt-Construction"><a href="#Application-of-the-Component-Description-Method-in-Prompt-Construction" class="headerlink" title="Application of the Component Description Method in Prompt Construction"></a>Application of the Component Description Method in Prompt Construction</h3><p>Based on the above philosophy, we introduced the component description method into our prompt construction. Taking backend development as an example, we designed up to 10 standardized dimensions for each component, covering aspects such as class names, method names, and exception handling. This method does not simply replicate the conventional framework concept; rather, the “components” here represent the basic units of a structured prompt that break down both functional responsibilities and the implementation process in detail.</p>
<p>Component_Description.png</p>
<p>The introduction of the component description method ensures that each prompt element is both self-contained and seamlessly integrated with others. By clearly defining its core responsibility and precisely specifying attributes and operational scope, we effectively avoid confusion and overlap between components, thereby safeguarding the integrity of the overall prompt and ensuring consistency in the generated code. This design not only significantly enhances maintainability but also provides robust support for tackling complex business scenarios.</p>
<h3 id="Overall-Framework-for-Structured-Prompt-Design"><a href="#Overall-Framework-for-Structured-Prompt-Design" class="headerlink" title="Overall Framework for Structured Prompt Design"></a>Overall Framework for Structured Prompt Design</h3><p>Building on the component definitions, we further established a comprehensive framework for structured prompt design, divided into the following five parts:</p>
<ul>
<li><strong>Requirement Anchoring:</strong> Accurately describing business requirements to ensure precise development targets.</li>
<li><strong>Structural Definition:</strong> Clarifying the dependencies and interactions among the modules required to implement functionality.</li>
<li><strong>Task Scheduling:</strong> Breaking down overall requirements into specific operational units and systematically defining each component to form a coherent workflow.</li>
<li><strong>Common Tasks:</strong> Standardizing high-frequency operations—such as data validation and exception handling—using template-driven solutions.</li>
<li><strong>Constraint Control:</strong> Setting up safety boundaries for the entire system by limiting the scope of component calls and references to prevent issues arising from unclear boundaries.</li>
</ul>
<p>Throughout this process, we adhere to two golden principles: first, the abstraction of the essence must take precedence over mere feature descriptions—only by clearly defining a component’s core responsibilities can we avoid superficial enumeration. Second, components should be regarded as logical units rather than merely fragments of code; similar to an excellent screenplay that emphasizes a character’s internal motivations rather than dictating every detail of an actor’s performance. Guided by these principles, the framework for structured prompt design has enabled our team to develop a systematic, rigorous, and highly efficient prompting system, thereby greatly enhancing overall development efficiency and code quality.</p>
<p>Structured_prompts_strategy.png</p>
<h2 id="Prompt-Engineering-Governance-Strategy-for-AI-Assets"><a href="#Prompt-Engineering-Governance-Strategy-for-AI-Assets" class="headerlink" title="Prompt Engineering: Governance Strategy for AI Assets"></a>Prompt Engineering: Governance Strategy for AI Assets</h2><p>Ensuring that prompts remain effective throughout the development process requires more than just crafting high-quality prompts—it necessitates a comprehensive governance strategy. We have divided prompt governance into multiple layers: the rule layer, the industry-specific abstract solution layer, the specific solution implementation layer, and the AI execution layer. Responsibilities are clearly delineated across these layers, with architects, technical leads, and developers each playing their part to maintain high standards and sustainability of our prompt assets.</p>
<p>prompts_governance_policy.png</p>
<p>In our pilot projects, we have already integrated logging rules into a predefined workflow, placing them at the rule layer to ensure that, prior to code generation, the necessary safety and quality standards are embedded via prompts. This approach not only ensures that the generated code adheres to logging standards but also builds a robust safety barrier for the entire system. As implementation continues, this governance strategy will be further refined and extended to a broader range of development scenarios, providing structured assurance for quality control and process management in software engineering.</p>
<h2 id="Analysis-of-a-Practical-Project-Example"><a href="#Analysis-of-a-Practical-Project-Example" class="headerlink" title="Analysis of a Practical Project Example"></a>Analysis of a Practical Project Example</h2><p>To illustrate the effectiveness of structured prompts more intuitively, let’s consider an API project for retrieving user permission information. This API is designed not only to support multi-criteria queries based on user ID, email, name, and role, but also to handle pagination, sorting, and the grouping and merging of data. In practice, we systematically organized and written the prompts according to the modules—requirements, structure, tasks, common tasks, and constraint controls. In the component definitions, we strictly adhered to the component description method and the core guiding principles of prompt construction. With this comprehensive framework, we successfully implemented an API that dynamically constructs query conditions based on multiple parameters and handles complex data grouping and merging.</p>
<p>Statistical results indicate that for the backend API module, the team employed 6 sets of prompts totaling 592 lines, which resulted in 1849 lines of generated code and modifications or creations of 37 files. Such a comprehensive practice covering complex business scenarios not only validates the feasibility of the structured prompt model but also significantly enhances delivery efficiency and code quality, heralding a revolutionary approach to traditional development methods.</p>
<p>Examples_of_project_practices.png</p>
<p>During the project, we also encountered real-world challenges and gathered valuable experiences. For teams new to this model, we found that there is no need to write prompts entirely from scratch—effective prompts can be extracted from existing code, thereby enabling rapid implementation and iterative refinement of the prompt system.</p>
<h2 id="Tips-and-Practical-Advice-for-Writing-Effective-Prompts"><a href="#Tips-and-Practical-Advice-for-Writing-Effective-Prompts" class="headerlink" title="Tips and Practical Advice for Writing Effective Prompts"></a>Tips and Practical Advice for Writing Effective Prompts</h2><p>Based on multiple projects, we have developed several strategies for writing high-quality prompts. First, when a solution already exists in current code, AI can be used to automatically parse and extract effective prompts, which can then be further refined. This approach not only saves time but also avoids the risks of starting from scratch. Second, when a solution is still in a developer’s mind, leveraging a reusable structured strategy and adjusting details according to the task at hand can quickly produce prompts that meet expectations. For those situations where the solution is not immediately clear, we recommend engaging in an open collaborative exploration with AI, gradually converging on ideas before using a structured template to generate initial prompts, followed by necessary manual refinement.</p>
<p>Our practical experience has also shown that it is crucial to avoid excessive abstraction when writing prompts. For simpler scenarios, there is often no need to develop an overly complex prompting system; direct conversational coding can be more efficient. Moreover, prompt writing should strike a balance between articulating the essence and detailing features—ensuring clarity in functionality and responsibilities without neglecting essential details. Ultimately, whether the aim is to generate excellent code via AI or to streamline subsequent review and modifications by developers, the final prompts must be both highly readable and practical, conveying the intended idea in clear, natural language.</p>
<p>Advice_of_practice.png</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In summary, prompt-driven development represents a novel software development model with unprecedented innovative potential. With the systematic design of structured prompts and rigorous governance strategies, we have successfully harnessed AI’s potential for code generation while significantly enhancing development efficiency and code quality. This approach has introduced a fundamentally new mode of thinking and working within our team.</p>
<p>Looking ahead, we will continue to monitor cutting-edge AI technologies and further refine our prompt design and governance strategies in even more complex scenarios. We anticipate that, propelled by ongoing exploration and practice by developers, the deep integration of human and AI efforts will usher in a new era in software development—driving the entire industry toward a more efficient and intelligent future. Through continuous iteration and optimization, we are confident that structured prompts will become a core technology in engineering practice, injecting endless innovative energy and competitive advantages into software development.</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><p>After this article was published externally, discussions ensued around the saying “features determine details, while essence defines boundaries” I noticed that there are varying interpretations regarding the basic definitions of “features” and “essence.” Therefore, I have included their fundamental definitions here to harmonize our understanding and help clarify the deeper meaning behind the statement.</p>
<p><strong>Features:</strong><br>Refers to the observable and describable specific attributes of a problem or requirement, including input&#x2F;output formats, constraints, interaction scenarios, technical parameters, and other explicit elements.<br><em>Core characteristics:</em> Quantifiable, verifiable, and concrete (readily observable).</p>
<p><strong>Essence:</strong><br>Refers to the fundamental conflict or core objective underlying a problem, which serves as the foundational logic determining the effectiveness of a solution.<br><em>Core characteristics:</em> Abstract, directional, and non-negotiable (the decisive factor that defines the solution).</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2024/12/11/guidelines-prompts-driven-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/guidelines-prompts-driven-development/" class="post-title-link" itemprop="url">Guidelines of Prompts Driven Development</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-11 17:00:00 / 修改时间：17:47:01" itemprop="dateCreated datePublished" datetime="2024-12-11T17:00:00+08:00">2024-12-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>This document outlines the structure and steps necessary to implement a business function within a software application, focusing on granularity, implementation steps, and the relationships between various components in the architecture.</p>
<h3 id="Business-Function-Overview"><a href="#Business-Function-Overview" class="headerlink" title="Business Function Overview"></a>Business Function Overview</h3><p>A business function refers to a specific operation or capability that a software application provides to fulfill business requirements. This can range from simple tasks like retrieving data to more complex operations like processing transactions.</p>
<h4 id="Granularity"><a href="#Granularity" class="headerlink" title="Granularity"></a>Granularity</h4><ul>
<li><strong>Minimum Granularity</strong>: One method</li>
<li><strong>Highest Granularity</strong>: One API</li>
</ul>
<h3 id="Implementation-Steps"><a href="#Implementation-Steps" class="headerlink" title="Implementation Steps"></a>Implementation Steps</h3><p>The implementation of a business function involves multiple layers, each with specific responsibilities. Below are the detailed steps required for implementing this function.</p>
<h4 id="Standard-Components"><a href="#Standard-Components" class="headerlink" title="Standard Components"></a>Standard Components</h4><ol>
<li><p><strong>Component Structure</strong></p>
<ul>
<li><strong>Class Name</strong>: Describe the class name</li>
<li><strong>Method Name</strong>: Describe the method name</li>
<li><strong>Responsibility</strong>: Describe the responsibilities of the component</li>
<li><strong>Request Body</strong>: Describe the request parameters (use ‘no parameters’ if there are none)</li>
<li><strong>Return Body</strong>: Returns data of type {Return Type}</li>
<li><strong>Endpoint</strong>: Describe the endpoint path</li>
<li><strong>Request Method</strong>: {GET&#x2F;POST&#x2F;PUT&#x2F;DELETE}</li>
<li><strong>Return Status Code</strong>: {HTTP status code}</li>
<li><strong>Attribute Definition</strong>: Define attributes as needed</li>
<li><strong>Static Members</strong>: List any static members if applicable</li>
<li><strong>Exceptions Handling</strong>: Describe how exceptions will be handled</li>
<li><strong>Elements</strong>: Identify any other necessary elements</li>
</ul>
</li>
<li><p><strong>Regular Example</strong></p>
<h5 id="Backend-Components"><a href="#Backend-Components" class="headerlink" title="Backend Components"></a>Backend Components</h5><ul>
<li><p><strong>Controller</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;Controller</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Endpoint: <code>/&#123;endpoint&#125;</code></li>
<li>Request Method: {GET&#x2F;POST&#x2F;PUT&#x2F;DELETE}</li>
<li>Request Body: {Describe the request parameters, write ‘no parameters’ if there are none}</li>
<li>Return Body: Returns data of type {Return Type}</li>
<li>Responsibility:<ul>
<li>Handling HTTP requests</li>
<li>Parameter verification</li>
<li>Call application services</li>
<li>Processing response</li>
</ul>
</li>
<li>Return Status Code: {HTTP status code}</li>
</ul>
</li>
<li><p><strong>Service</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;DomainService</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Responsibility:<ul>
<li>Implement core business logic</li>
<li>Maintain object status</li>
<li>Ensure business rules</li>
</ul>
</li>
<li>Request Body: {Description of Request Parameters}</li>
<li>Return Body: Returns data of type {Return Type}</li>
</ul>
</li>
<li><p><strong>Repository</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;Repository</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Responsibility:<ul>
<li>Implement data persistence</li>
<li>Implement data query</li>
<li>Database operation encapsulation</li>
</ul>
</li>
<li>Request Body: {Description of Request Parameters}</li>
<li>Return Body: Returns data of type {Return Type}</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Frontend Frameworks</strong><br>Utilize popular frameworks such as React, Angular, or Vue for building user interfaces that interact with the backend.</p>
</li>
</ol>
<h3 id="API-Implementation-Example-of-Hexagonal-architecture-No-architecture-modeling"><a href="#API-Implementation-Example-of-Hexagonal-architecture-No-architecture-modeling" class="headerlink" title="API Implementation Example of Hexagonal architecture(No architecture modeling)"></a>API Implementation Example of Hexagonal architecture(No architecture modeling)</h3><p>To implement an API that can update an entity (e.g., user information), follow these guidelines:</p>
<ul>
<li><p><strong>Controller Layer</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;Controller</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Endpoint: <code>/&#123;endpoint&#125;</code></li>
<li>Request Method: {GET&#x2F;POST&#x2F;PUT&#x2F;DELETE}</li>
<li>Request Body: {Describe the request parameters, write ‘no parameters’ if there are none}</li>
<li>Return Body: Returns data of type {Return Type}</li>
<li>Logic: Call the corresponding method of the Application layer to obtain data.</li>
<li>Return Status Code: {HTTP status code}</li>
</ul>
</li>
<li><p><strong>Application Service Layer</strong></p>
<ul>
<li>Class Name: <code>&#123;EntityName&#125;ApplicationService</code></li>
<li>Method Name: <code>&#123;methodName&#125;</code></li>
<li>Logic: Call relevant methods of the Query layer or Domain layer.</li>
<li>Request Body: {Description of Request Parameters}</li>
<li>Return Body: Returns data of type {Return Type}</li>
<li>Exception Handling Required.</li>
</ul>
</li>
<li><p><strong>Query Layer</strong><br>This layer is responsible for obtaining resources.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Name: `&#123;EntityName&#125;Query`</span><br><span class="line">Method Name: `&#123;methodName&#125;`</span><br><span class="line">Logic: Call infrastructure-related methods.</span><br><span class="line">Request Body: &#123;Description of Request Parameters&#125;</span><br><span class="line">Return Body: Returns data of type &#123;Return Type&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Domain Layer</strong><br>Implements business logic details.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Name:`&#123;EntityName&#125;DomainService`</span><br><span class="line">Method Name:`&#123;methodName&#125;`</span><br><span class="line">Logic: Call relevant methods of the Infrastructure layer.</span><br><span class="line">Request Body:&#123;Description of Request Parameters&#125;</span><br><span class="line">Return Body:&#123;Returns data of type &#123;Return Type&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Repository Layer</strong><br>Handles database interactions.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Name:`&#123;EntityName&#125;Repository`</span><br><span class="line">Method Name:`&#123;methodName&#125;`</span><br><span class="line">Logic: Call relevant methods of the database.</span><br><span class="line">Request Body:&#123;Description of Request Parameters&#125;</span><br><span class="line">Return Body:&#123;Returns data of type &#123;Return Type&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Testing-Strategy"><a href="#Testing-Strategy" class="headerlink" title="Testing Strategy"></a>Testing Strategy</h3><p>Generate unit tests and integration tests based on the methods defined in each layer. Use tools and frameworks appropriate for your programming environment to facilitate this process.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Implementing a business function requires careful planning and adherence to structured guidelines across various layers of an application. By following these guidelines, developers can ensure that their applications are robust, maintainable, and scalable.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2024/11/15/refactoring-with-cursor-en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/15/refactoring-with-cursor-en/" class="post-title-link" itemprop="url">Building Prompts Using the ReAct Framework for Efficient Code Refactoring with Cursor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-15 19:00:00" itemprop="dateCreated datePublished" datetime="2024-11-15T19:00:00+08:00">2024-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-09 12:48:50" itemprop="dateModified" datetime="2025-01-09T12:48:50+08:00">2025-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Introduction-A-Journey-from-Simple-to-Complex-AI-Programming"><a href="#Introduction-A-Journey-from-Simple-to-Complex-AI-Programming" class="headerlink" title="Introduction: A Journey from Simple to Complex AI Programming"></a>Introduction: A Journey from Simple to Complex AI Programming</h2><p>In my previous blog, I enthusiastically shared how I used Cursor to achieve a 0 to 1 implementation of an AI tool in just half a day. At that time, I felt like a child who had just learned to ride a bicycle, filled with excitement about this “new toy.” However, I soon realized that this was just the tip of the iceberg. While code generation is thrilling, the challenges we face in actual development are far more complex.<br>This realization propelled me into a deeper exploration, particularly in the area of code refactoring. I discovered that Cursor exhibited surprising potential. When I provided it with some refactoring instructions, it not only understood my intentions but also restructured the code as expected, and at an astonishing speed. This made me dream: if I could apply this skill in daily development, I could be leisurely “fishing” while others were still buried in refactoring!</p>
<h2 id="The-Reality-Check-The-Dilemma-of-Refactoring-Complex-Projects"><a href="#The-Reality-Check-The-Dilemma-of-Refactoring-Complex-Projects" class="headerlink" title="The Reality Check: The Dilemma of Refactoring Complex Projects"></a>The Reality Check: The Dilemma of Refactoring Complex Projects</h2><p>However, reality often delivers a harsh blow. When I confidently applied this straightforward refactoring approach to real projects, I quickly hit a wall. The complexity of real projects far exceeded that of simple AI tool code projects, and simple prompts felt like trying to use a toothpick to move an elephant.</p>
<p><strong>Main Issues Encountered:</strong></p>
<ol>
<li><strong>Uncontrolled Scope of Changes</strong>: Each refactor felt like a random walk without a map.</li>
<li><strong>Chaotic Refactoring Strategies</strong>: Relying entirely on large models to select refactoring strategies was akin to handing the steering wheel to a blindfolded driver.</li>
<li><strong>Contextual Understanding Barriers</strong>: Even with @Codebase, Cursor seemed oblivious to the overall project context, leading to aimless refactoring.</li>
<li><strong>Code Review Burden</strong>: Each change required meticulous review; otherwise, it felt like dancing on the edge of a knife.</li>
<li><strong>Vicious Cycle</strong>: The more I refactored, the messier it became, ultimately forcing me to start over and fall into a “start over - fail again” loop.</li>
</ol>
<p><strong>Root Cause Analysis:</strong><br>After deep reflection, several core reasons emerged:</p>
<ol>
<li><strong>Excessive Logical Complexity:</strong> Real projects often contain intricate business logic and conditional judgments.</li>
<li><strong>Lack of Framework Knowledge:</strong> There was insufficient onboarding for AI regarding frameworks.</li>
<li><strong>Diversity in Coding Styles:</strong> Variations in coding styles among different developers posed challenges.</li>
<li><strong>Overwhelming Contextual Burden:</strong> Too many interrelated codes formed a complex web of dependencies.</li>
<li><strong>Unpredictable Behavior:</strong> It was impossible to accurately anticipate the AI’s next actions.</li>
</ol>
<h2 id="Human-vs-Machine-Differences-in-Refactoring-Mindsets"><a href="#Human-vs-Machine-Differences-in-Refactoring-Mindsets" class="headerlink" title="Human vs. Machine: Differences in Refactoring Mindsets"></a>Human vs. Machine: Differences in Refactoring Mindsets</h2><p>To find a breakthrough, I pondered why human developers could navigate refactoring relatively smoothly while AI frequently stumbled.</p>
<p><strong>Human Developer’s Refactoring Approach:</strong></p>
<ol>
<li><strong>Systematic Analysis:</strong> Identifying and eliminating code smells first to enhance readability and scalability.</li>
<li><strong>Object-Oriented Optimization:</strong> Refactoring based on best practices in object-oriented design.</li>
<li><strong>Architectural Adjustments:</strong> Reorganizing code into appropriate hierarchical structures.</li>
<li><strong>Testing Validation:</strong> Ensuring that the refactored code still meets expected behaviors.<br><strong>AI’s Refactoring Approach:</strong> It resembles a mechanical worker simply repeating the action of “modifying code,” lacking the systematic thinking and strategic planning we expect.</li>
</ol>
<h2 id="Inspiration-Strikes-Insights-from-the-ReAct-Framework"><a href="#Inspiration-Strikes-Insights-from-the-ReAct-Framework" class="headerlink" title="Inspiration Strikes: Insights from the ReAct Framework"></a>Inspiration Strikes: Insights from the ReAct Framework</h2><p>In my quest for solutions, I encountered Agent and ReAct along with Chain-of-Thought (CoT), which sparked an idea. If we could enable AI to think like humans and reason in ways we expect, could we overcome the current challenges?</p>
<h3 id="Overview-of-the-ReAct-Framework"><a href="#Overview-of-the-ReAct-Framework" class="headerlink" title="Overview of the ReAct Framework"></a>Overview of the ReAct Framework</h3><p>The ReAct framework was proposed by Shunyu Yao et al. in 2022 as a method that combines reasoning and action to enhance the performance of large language models (LLMs). This framework allows LLMs to alternately generate <strong>reasoning traces</strong> and <strong>task-specific operations</strong>, enabling models to induce, track, and update operational plans effectively while handling exceptions.</p>
<ul>
<li><strong>Interaction with External Tools:</strong> The ReAct framework enables LLMs to interact with external knowledge bases or environments for additional information, providing more reliable responses.</li>
<li><strong>Performance Improvement:</strong> Research shows that ReAct outperforms several advanced baseline models in language and decision-making tasks while enhancing LLMs’ interpretability and trustworthiness.</li>
<li><strong>Integration with Chain-of-Thought (CoT):</strong> Combining ReAct with CoT allows for leveraging both internal knowledge and external information during reasoning for optimal results.</li>
</ul>
<h2 id="Practice-Constructing-Refactoring-Specific-Prompts"><a href="#Practice-Constructing-Refactoring-Specific-Prompts" class="headerlink" title="Practice: Constructing Refactoring-Specific Prompts"></a>Practice: Constructing Refactoring-Specific Prompts</h2><p><strong>Designing Refactoring Steps:</strong></p>
<ol>
<li><strong>Basic Cleanup:</strong> Identify and address fundamental code smells.</li>
<li><strong>Object-Oriented Optimization:</strong> Apply best practices in object-oriented design.</li>
<li><strong>Architectural Adjustments:</strong> Restructure code according to hexagonal architecture standards.</li>
<li><strong>Error Fixing:</strong> Address obvious compilation errors.</li>
<li><strong>Manual Review:</strong> Supplement detail optimization.</li>
<li><strong>Test Fixes:</strong> Ensure all test cases pass.</li>
</ol>
<p><img src="/../images/new_refactoring_processing.jpg" alt="new_refactoring_processing.jpg"></p>
<p><strong>Designing Refactoring Prompt Template:</strong></p>
<ol>
<li><strong>Context Explanation:</strong> Provide architectural standards and best practice guidelines.</li>
<li><strong>Thinking Steps:</strong> Guide AI through systematic analysis.</li>
<li><strong>Observation Records:</strong> Document identified issues. </li>
<li><strong>Action Guidelines:</strong> Clearly outline specific refactoring steps.</li>
</ol>
<p><img src="/../images/prompt_design.jpg" alt="prompt_design.jpg"></p>
<p>Based on insights from ReAct and CoT, I designed a prompt for DDD refactoring on the current project (covering the first three steps):<br><strong>Prompt for Refactoring</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Context: In hexagonal architecture DDD implementation patterns, there are best practices and experiences regarding the design and implementation of Application Service, Domain Service, Query, and Port. Here are summarized experiences and suitable refactoring prompts:</span><br><span class="line"><span class="bullet">1.</span> Application Service</span><br><span class="line"><span class="bullet">    -</span> Primarily responsible for use case orchestration and transaction management without business logic; instead calls Domain Service for specific operations.</span><br><span class="line"><span class="bullet">2.</span> Domain Service</span><br><span class="line"><span class="bullet">    -</span> Contains core business logic handling complex business rules and operations as part of the domain model.</span><br><span class="line"><span class="bullet">3.</span> Port</span><br><span class="line"><span class="bullet">    -</span> Defines interfaces between applications and external systems, including definitions of Repository interfaces within inbound and outbound packages.</span><br><span class="line"></span><br><span class="line">Based on this context, please refer to @AcademyCourseDomainService.java for refactoring the current file; modifications involving @EnrollmentApplicationService.java can also be made. Use the ReAct framework following these thinking steps to analyze, observe, execute, and ultimately complete code refactoring.</span><br><span class="line">Thought-1: Are there any obvious code smells?</span><br><span class="line">Observation-1: There is a code smell: xxxx</span><br><span class="line">Action-1: Refactor using best practices corresponding to this code smell.</span><br><span class="line"></span><br><span class="line">Thought-2: Are there any particularly concerning code smells regarding object-oriented principles such as single responsibility principle (SRP), open/closed principle (OCP), Liskov substitution principle (LSP), dependency inversion principle (DIP), and interface segregation principle (ISP)?</span><br><span class="line">Observation-2: Several areas xxxx do not comply with SRP.</span><br><span class="line">Action-2: Understand best practices of SRP and perform code refactoring accordingly.</span><br><span class="line"></span><br><span class="line">Thought-3: What layer does the current file belong to? What responsibilities must be adhered to?</span><br><span class="line">Observation-3: The current file is a Domain service; some implementations xxxx do not align with domain service responsibilities.</span><br><span class="line">Action-3: Refactor these implementations based on Domain service responsibilities by analyzing which layer&#x27;s duties they belong to and relocating them accordingly.</span><br></pre></td></tr></table></figure>
<p>Output of Cursor composer:<br><img src="/../images/prompt_result_1.png" alt="prompt_result_1.png"><br><img src="/../images/prompt_result_2.png" alt="prompt_result_2.png"></p>
<h2 id="Experimental-Results-and-Lessons-Learned"><a href="#Experimental-Results-and-Lessons-Learned" class="headerlink" title="Experimental Results and Lessons Learned"></a>Experimental Results and Lessons Learned</h2><p>Through multiple experiments, this ReAct-based prompt writing method demonstrated significant advantages:</p>
<ol>
<li><strong>Higher Result Accuracy:</strong> This refactoring method achieved expected results quickly within two or three interactions. The combination of ReAct and CoT allowed models to integrate information effectively during reasoning processes, reducing errors and uncertainties significantly.</li>
<li><strong>Goal-Oriented Thinking Process:</strong> After adopting the ReAct framework, the model’s reasoning direction aligned more closely with user expectations rather than being influenced by hallucinations (i.e., generating false information). By introducing additional information sources (observational steps provide necessary information), models could verify and update their reasoning paths in real time.</li>
<li><strong>Visualized Thinking and Modification Process:</strong> In Cursor’s composer mode, users can clearly see intermediate thought processes and modifications. This transparency enables developers to track each modification step better understand how models arrive at conclusions.</li>
</ol>
<h3 id="Key-Factors-for-Improved-Outcomes"><a href="#Key-Factors-for-Improved-Outcomes" class="headerlink" title="Key Factors for Improved Outcomes:"></a>Key Factors for Improved Outcomes:</h3><ol>
<li><strong>Clear Boundaries:</strong> Context limits AI’s behavioral scope.</li>
<li><strong>Defined Steps:</strong> Guides AI through predetermined thought processes during refactoring.</li>
<li><strong>Feedback Loop Closure:</strong> Each step has clear observation and action guidelines.</li>
</ol>
<h3 id="Shift-in-Mindset"><a href="#Shift-in-Mindset" class="headerlink" title="Shift in Mindset:"></a>Shift in Mindset:</h3><p>This process made me realize that using AI effectively hinges on shifting our mindset from “problem-oriented” to “guided collaboration.” Our roles should be:</p>
<ul>
<li>Humans handle analysis and planning,</li>
<li>AI executes specific details,</li>
<li>Establish bridges through well-designed prompts.</li>
</ul>
<h2 id="Conclusion-A-New-Paradigm-for-AI-Coding-Assistants"><a href="#Conclusion-A-New-Paradigm-for-AI-Coding-Assistants" class="headerlink" title="Conclusion: A New Paradigm for AI Coding Assistants"></a>Conclusion: A New Paradigm for AI Coding Assistants</h2><p>This exploration not only helped me tackle the challenges of code refactoring but also imparted an important lesson: AI is not omnipotent; however, through proper guidance, it can become a powerful assistant that amplifies our capabilities. When we learn to interact with AI as “coaches” rather than “questioners,” we often achieve better results.<br>Of course, this brings new demands; understanding best practices and methodologies becomes essential when collaborating with AI so that we can guide it effectively towards completing tasks correctly.<br>This shift in thinking allows us to better leverage human creativity alongside AI execution capabilities—enhancing both code quality and development efficiency (ideally saving time should promote improved code quality rather than merely pursuing high output; otherwise, we risk falling into another quagmire where chasing output neglects quality). Balancing efficiency with quality is crucial; by emphasizing readability, maintainability, and sound best practices in our codebase, we can accelerate development while ensuring long-term software health and stability.<br>In future endeavors, this human-machine collaborative model may emerge as a new paradigm in software development.</p>
<h2 id="Final-Note-Prompt-Sharing"><a href="#Final-Note-Prompt-Sharing" class="headerlink" title="Final Note: Prompt Sharing"></a>Final Note: Prompt Sharing</h2><p>Through practice, we’ve developed a prompt template specifically targeting code smell refactoring. If you’re interested in addressing code smells in your projects, feel free to try out this Prompt Template available on our site tailored for developers seeking efficient prompts that enhance their experience using Cursor for refactoring—especially aimed at those looking to optimize their refactoring processes through AI assistance.<br>This prompt template site aims at providing practical resources designed for developers looking for actionable templates that enhance their experience using Cursor for refactoring tasks while minimizing potential hallucinations during such processes.<br>We encourage everyone using Cursor or other AI coding assistance tools to share effective prompts within this repository. Together we can build a practical collection of refactoring prompts that enhance daily efficiency and code quality during development tasks!</p>
<p>Thank you all for reading!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2024/11/04/refactoring-with-cursor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/04/refactoring-with-cursor/" class="post-title-link" itemprop="url">参考ReAct框架构建Prompt，使用Cursor高效对代码进行重构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-04 16:42:03" itemprop="dateCreated datePublished" datetime="2024-11-04T16:42:03+08:00">2024-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-06 17:26:37" itemprop="dateModified" datetime="2024-11-06T17:26:37+08:00">2024-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言：从简单到复杂的AI编程之旅"><a href="#前言：从简单到复杂的AI编程之旅" class="headerlink" title="前言：从简单到复杂的AI编程之旅"></a>前言：从简单到复杂的AI编程之旅</h2><p>还记得<a target="_blank" rel="noopener" href="https://mail.google.com/mail/u/0/#search/%F0%9F%A4%AF/KtbxLrjhzfdqjKmxgVHVCjNmBkwrQzSPSq"><strong>上一篇博客</strong></a>中，我兴致勃勃地分享了如何用Cursor在短短半天内完成AI工具的从0到1实现。那时的我，就像刚学会骑自行车的孩子，对这个”新玩具”充满了热情。但很快，我就意识到这只是冰山一角。单纯的代码生成固然令人兴奋，但在实际开发中，我们面临的挑战远不止于此。</p>
<p>于是，我开始了一段更深入的探索之旅。特别是在代码重构这个领域，我发现Cursor展现出了令人惊喜的潜力。当我给它一些重构指令时，它不仅能理解我的意图，还能按照预期重构代码，而且速度快得惊人。这让我不禁幻想：如果能把这项技能应用到日常开发中，那岂不是能在别人还在埋头重构时，我已经可以优哉游哉地”摸鱼”了？</p>
<h2 id="现实给的一记重拳：复杂项目重构的困境"><a href="#现实给的一记重拳：复杂项目重构的困境" class="headerlink" title="现实给的一记重拳：复杂项目重构的困境"></a>现实给的一记重拳：复杂项目重构的困境</h2><p>然而，现实总是喜欢给我们一记重拳。当我满怀信心地将这种简单直接的重构方式应用到实际项目中时，很快就碰了壁。由于真实项目的复杂度远超简单的AI工具代码项目，简单的prompt在这里就像是用牙签撬动大象。</p>
<p><strong>遇到的主要问题：</strong></p>
<ol>
<li><strong><strong>改动范围失控</strong></strong>：就像是没有地图的探险，每次重构都像是在随机漫步。</li>
<li><strong><strong>重构策略混乱</strong></strong>：完全依赖大模型自动选择重构策略，就像是把方向盘交给了蒙着眼睛的司机。</li>
<li><strong><strong>上下文理解障碍</strong></strong>：即使使用了@Codebase，Cursor依然像是对整个项目背景一无所知，重构起来漫无目标。</li>
<li><strong><strong>代码审查负担</strong></strong>：每次改动都需要仔细审查，否则就像是在刀尖上跳舞，提心吊胆。</li>
<li><strong><strong>恶性循环</strong></strong>：越重构越乱，最后不得不推倒重来，陷入了一个”推倒重来-再次失败”的死循环。</li>
</ol>
<p><strong>问题根源分析：</strong><br>经过深入思考，总结出了几个核心原因：</p>
<ol>
<li><strong><strong>逻辑复杂度过高</strong></strong>：现实项目往往包含复杂的业务逻辑和条件判断。</li>
<li><strong><strong>框架知识欠缺</strong></strong>：没有给AI进行适当的框架Onboarding。</li>
<li><strong><strong>代码风格多样性</strong></strong>：不同开发者的编码风格差异带来的挑战。</li>
<li><strong><strong>上下文负担过重</strong></strong>：相互关联的代码太多，形成了复杂的依赖网络。</li>
<li><strong><strong>行为不可预测</strong></strong>：无法准确预知AI的下一步操作。</li>
</ol>
<h2 id="人机对比：重构思维的差异"><a href="#人机对比：重构思维的差异" class="headerlink" title="人机对比：重构思维的差异"></a>人机对比：重构思维的差异</h2><p>为了找到突破口，我开始思考：为什么同样是重构，人类开发者能够相对顺利地完成，而AI却频频踩坑？</p>
<p>人类开发者的重构方式：</p>
<ol>
<li><strong><strong>系统性分析</strong></strong>：首先识别和消除code smell，提升代码的可读性和可扩展性。</li>
<li><strong><strong>面向对象优化</strong></strong>：基于面向对象的最佳实践进行重构。</li>
<li><strong><strong>架构层面调整</strong></strong>：将代码重新组织到合适的层次结构中。</li>
<li><strong><strong>测试验证</strong></strong>：确保重构后的代码仍然符合预期行为。</li>
</ol>
<p>AI的重构方式：就像一个机械工人，简单地重复”修改代码”这个动作，缺乏我们<strong>期望的</strong>系统性思维和策略性规划。</p>
<h2 id="灵感突现：ReAct框架的启发"><a href="#灵感突现：ReAct框架的启发" class="headerlink" title="灵感突现：ReAct框架的启发"></a>灵感突现：ReAct框架的启发</h2><p>在寻找解决方案的过程中，我接触到了Agent和ReAct以及COT，这让我眼前一亮。如果能让AI像人类一样思考并且按照人类期望的方式进行思考，是否就能克服当前的困境？</p>
<h3 id="ReAct框架简介"><a href="#ReAct框架简介" class="headerlink" title="ReAct框架简介"></a>ReAct框架简介</h3><p>ReAct 框架是由 Shunyu Yao 等人在 2022 年提出的一种方法，旨在结合推理与行动，以提高大型语言模型（LLMs）的性能。该框架允许 LLMs 交替生成<strong>推理轨迹</strong>和<strong>任务特定操作</strong>，从而使模型能够诱导、跟踪和更新操作计划，并有效处理异常情况。</p>
<ul>
<li><strong><strong>与外部工具的交互</strong></strong>：ReAct 框架使 LLMs 能够与外部知识库或环境进行交互，从而获取额外信息，提供更可靠的回应。</li>
<li><strong><strong>性能提升</strong></strong>：研究表明，ReAct 在语言和决策任务上表现优于多个先进的基线模型，同时提高了 LLMs 的可解释性和可信度。</li>
<li><strong><strong>与链式思考（CoT）的结合</strong></strong>：将 ReAct 与链式思考结合使用，可以在推理过程中同时利用内部知识和外部信息，从而取得最佳效果。</li>
</ul>
<h2 id="实践：构建重构专用的Prompt"><a href="#实践：构建重构专用的Prompt" class="headerlink" title="实践：构建重构专用的Prompt"></a>实践：构建重构专用的Prompt</h2><p><strong>重构步骤设计：</strong></p>
<ol>
<li><strong><strong>基础清理</strong></strong>：识别和处理基本的code smell</li>
<li><strong><strong>面向对象优化</strong></strong>：应用面向对象的最佳实践</li>
<li><strong><strong>架构调整</strong></strong>：根据六边形架构的规范重组代码</li>
<li><strong><strong>错误修复</strong></strong>：处理明显的编译错误</li>
<li><strong><strong>人工复查</strong></strong>：补充细节优化</li>
<li><strong><strong>测试修复</strong></strong>：确保所有测试用例通过</li>
</ol>
<p><img src="/../images/new_refactoring_processing.jpg" alt="new_refactoring_processing.jpg"></p>
<p><strong>重构Prompt模板设计：</strong></p>
<ol>
<li><strong><strong>上下文说明</strong></strong>：提供架构规范和最佳实践指南</li>
<li><strong><strong>思考步骤</strong></strong>：引导AI进行系统性分析</li>
<li><strong><strong>观察记录</strong></strong>：记录发现的问题</li>
<li><strong><strong>行动指南</strong></strong>：明确具体的重构步骤</li>
</ol>
<p><img src="/../images/prompt_design.jpg" alt="prompt_design.jpg"></p>
<p>基于ReAct和COT的启发，设计了一个用于当前项目上DDD重构的Prompt（包含重构设计的前3步）：<br><strong>Prompt for Refactoring</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Context: 在六边形架构的DDD实现模式中，Application Service、Domain Service、Query 以及 Port 的设计和实现有一些最佳实践和经验。以下是总结的经验和适合的重构提示：</span><br><span class="line"><span class="bullet">1.</span> Application Service</span><br><span class="line"><span class="bullet">    -</span> 主要负责用例编排和事务管理，不包含业务逻辑，而是调用 Domain Service 执行具体操作。</span><br><span class="line"><span class="bullet">2.</span> Domain Service</span><br><span class="line"><span class="bullet">    -</span> 包含核心业务逻辑，处理复杂业务规则和操作，是领域模型的一部分。</span><br><span class="line"><span class="bullet">3.</span> Port</span><br><span class="line"><span class="bullet">    -</span> 定义应用程序与外部系统之间接口，包括 inbound 和 outbound 包中的 Repository 接口定义。</span><br><span class="line"></span><br><span class="line">基于上述上下文。请参照 @AcademyCourseDomainService.java  对当前文件进行重构，如果涉及 @EnrollmentApplicationService.java  的修改，也可以进行修改。使用 ReAct 框架按照下面的思考步骤来指导此过程，以分析、观察、执行并最终完成代码重构。</span><br><span class="line">Thought-1：是否有明显的code smell？</span><br><span class="line">Observation-1：有code smell：xxxx</span><br><span class="line">Action-1：使用这个code smell 对应的最佳实践进行重构</span><br><span class="line"></span><br><span class="line">Thought-2：是否有特别需要注意的code smell，比如说面向对象的5大基本原则，单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则和接口隔离原则？</span><br><span class="line">Observation-2：这几个地方xxxx，不符合单一职责原则</span><br><span class="line">Action-2：了解单一职责原则的最佳实践，并进行代码重构</span><br><span class="line"></span><br><span class="line">Thought-3：当前文件是什么Layer，需要遵循哪些职责？</span><br><span class="line">Observation-3：当前的文件是Domain service，里面有些实现xxxx做的事情不属于domain service的职责</span><br><span class="line">Action-3：根据Domain service职责，对这几个实现进行重构，分析这些做的事情属于哪些layer的职责，将实现挪到对应的Layer中去</span><br></pre></td></tr></table></figure>
<p>Cursor composer的输出：<br><img src="/../images/prompt_result_1.png" alt="prompt_result_1.png"><br><img src="/../images/prompt_result_2.png" alt="prompt_result_2.png"></p>
<h2 id="实验效果与经验总结"><a href="#实验效果与经验总结" class="headerlink" title="实验效果与经验总结"></a>实验效果与经验总结</h2><p>通过多轮实验，这种基于ReAct的重构Prompt编写方法展现出了明显的优势：</p>
<ol>
<li><strong>更高的结果正确性：</strong> 这种重构方法能够在仅需两到三轮的互动中，快速达成预期结果。与传统方法相比，ReAct和COT的结合使得模型能够更有效地整合信息和推理过程，从而减少了错误和不确定性。这种高效性使得用户在处理复杂问题时，能够更快地获得准确答案。</li>
<li><strong>目标导向的思考过程：</strong> 采用ReAct框架后，模型的思考方向更加符合用户的期望，而不是受到幻觉（即生成不实信息）的影响。通过引入额外信息源（观察的步骤会引入需要的信息），模型能够实时验证和更新其推理路径，从而确保所生成的信息是基于事实而非虚构。这一特性显著提升了用户对模型输出的信任度。</li>
<li><strong>可视化的思考与修改过程：</strong> 在Cursor的composer模式中，用户可以清晰地看到思考和修改的中间过程。这种透明性让开发者能够追踪每一步的修改步骤，从而更好地理解模型如何得出最终结论。通过展示具体的推理轨迹和所采取的行动，用户不仅能审视模型的决策过程，还能对其进行必要的调整和优化。</li>
</ol>
<h3 id="效果提升的关键因素："><a href="#效果提升的关键因素：" class="headerlink" title="效果提升的关键因素："></a>效果提升的关键因素：</h3><ol>
<li><strong><strong>边界清晰</strong></strong>：通过Context限定了AI的行为范围</li>
<li><strong><strong>步骤明确</strong></strong>：让AI按照预定的思维方式进行重构</li>
<li><strong><strong>反馈闭环</strong></strong>：每个步骤都有明确的观察和行动指南</li>
</ol>
<h3 id="思维方式的转变："><a href="#思维方式的转变：" class="headerlink" title="思维方式的转变："></a>思维方式的转变：</h3><p>这个过程让我意识到，使用AI的关键在于转变思维方式：从”问题导向”转向”引导式合作”。我们需要做的是：</p>
<ul>
<li>人负责分析和规划</li>
<li>AI负责执行具体细节</li>
<li>通过精心设计的Prompt建立桥梁</li>
</ul>
<h2 id="结语：AI编码助手使用的新范式"><a href="#结语：AI编码助手使用的新范式" class="headerlink" title="结语：AI编码助手使用的新范式"></a>结语：AI编码助手使用的新范式</h2><p>这次的探索不仅帮助我解决了代码重构的难题，更重要的是让我领悟到了一个道理：AI不是万能的，但通过正确的引导，它可以成为我们强大的助手，起到能力放大器的作用。当我们学会用”教练”而不是”提问者”的身份与AI互动时，往往能获得更好的结果。当然，这也给我们带来了新的要求：在与AI进行协作时，了解<strong>最佳实践</strong>和<strong>方法论</strong>成为了前提条件，只有这样，我们才能更有效地引导AI以正确的方式完成工作。</p>
<p>这种思维方式的转变，让我们能够更好地发挥人类的创造力和AI的执行力，从而提升<strong>代码质量</strong>和<strong>开发效率</strong>（在理想情况下，提升开发效率应当将节省下来的时间来促进代码质量的提高，而不是单纯追求高产出，否则我们可能会陷入另一个无法自拔的漩涡。追逐产出而忽视质量，最终仍然会导致技术债务高筑，增加维护成本，甚至影响项目的可持续性。因此，平衡效率与质量至关重要。通过注重代码的可读性、可维护性和合理的使用最佳实践，我们不仅能够提高开发速度，还能确保软件的长期健康和稳定性）。在未来，这种人机协作的模式也许会成为软件开发的一种新范式。</p>
<h2 id="最后：Prompt分享"><a href="#最后：Prompt分享" class="headerlink" title="最后：Prompt分享"></a>最后：Prompt分享</h2><p>经过实践，我们总结出了一个专门针对代码基础异味（code smell）重构的提示模板。如果你对代码基础异味的重构感兴趣，欢迎尝试使用这个站点下的<a target="_blank" rel="noopener" href="https://aigo.netlify.app/docs/codesemell/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93"><strong>Prompt模板</strong></a>。这个重构Prompt模版站点是为开发者量身打造的资源分享平台，旨在提供高效可行的Prompt模版，以提升使用Cursor进行重构的体验，主要面向希望通过AI优化重构过程的同事。其Prompt特色在于能够显著降低AI在重构时可能出现的幻觉。大家可以通过参考站点的<a target="_blank" rel="noopener" href="https://aigo.netlify.app/#%e5%bf%ab%e9%80%9f%e5%bc%80%e5%a7%8b"><strong>Quick Start</strong></a>操作快速上手，从而提升重构的准确率和效率，让大家更专注于最佳实践和方法论的思考。此外，我们也欢迎大家在使用Cursor或其他AI代码辅助工具的过程中，将有效的提示分享至<a target="_blank" rel="noopener" href="https://github.com/AI-performance-improvement/prompt-helper"><strong>这个代码库</strong></a>中。通过共同努力，我们可以建立一个实用的重构提示集合，帮助大家提升日常的重构效率和代码质量。后续我们将逐步总结出面向对象重构及DDD等框架型代码重构的可复用Prompt模板，并上传到这个<a target="_blank" rel="noopener" href="https://aigo.netlify.app/docs/codesemell/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93/"><strong>站点</strong></a>，如有需要请持续关注。</p>
<p>到此，我们的讨论就告一段落了。感谢大家的阅读和关注!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wiilie Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wiilie Zhang</span>
</div>
  <div class="powered-by">
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
