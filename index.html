<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gszhangwei.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Willie&#39;s Blog">
<meta property="og:url" content="hhttps://gszhangwei.github.io/index.html">
<meta property="og:site_name" content="Willie&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wiilie Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="hhttps://gszhangwei.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Willie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Willie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/05/22/PDD-in-Data-Domain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/22/PDD-in-Data-Domain/" class="post-title-link" itemprop="url">PDD在DATA领域的应用实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-22 19:00:00 / 修改时间：15:41:35" itemprop="dateCreated datePublished" datetime="2025-05-22T19:00:00+08:00">2025-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近，由于项目安排，我有机会在一个数据项目中应用Prompt Driven Development（PDD）方法论。这次实践让我能够探索并补充PDD在数据领域的应用经验。坦诚地说，过程并不一帆风顺，但通过不懈的探索，最终找到了一条在复杂SQL业务场景下稳定使用PDD的路径，并获得了一些有价值的见解。下面将详细分享这个过程，以及从中探索出的PDD在DATA领域的可行路径。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="技术栈与项目目标"><a href="#技术栈与项目目标" class="headerlink" title="技术栈与项目目标"></a>技术栈与项目目标</h4><p>我们使用Python构建ETL的框架和过程，BigQuery构建数据表，GCP作为云平台。本次任务的主要目标是使用BigQuery构建一个复杂查询，将预测与实际收入数据进行全面对齐和补全，通过多层级匹配和统一标准，实现两种数据的一致比较，最终生成一份字段齐全、结构统一的对比报表，满足业务分析和决策支持需求。</p>
<p><strong>业务目标</strong></p>
<ul>
<li>将<strong>预测数据</strong>与<strong>实际收入数据</strong>关联对比，识别差异并补全缺失信息</li>
<li>按照机会、账户、市场和区域四个层级打标匹配结果，明确匹配深度</li>
<li>标准化关键字段(如合同类型、区域名称)，确保跨表数据口径一致</li>
<li>输出可直接支撑销售、财务和管理层分析的结构化对比数据集</li>
</ul>
<p><strong>核心流程</strong></p>
<ul>
<li><strong>多条件关联</strong>：依次按机会、账户、市场和区域四级进行数据匹配，并对匹配成功与未匹配记录分别打标</li>
<li><strong>基于快照扩展</strong>：对未匹配的行基于业务快照日期进行行扩展，保证所有时间点均有对齐的数据视图</li>
<li><strong>业务数据补全</strong>：对ID、名称、状态等缺失字段，按照优先级从不同数据源进行补充</li>
<li><strong>字段标准化</strong>：统一区域缩写为全称，转换特定合同类型，并补充额外标记字段</li>
<li><strong>汇总去重</strong>：合并所有中间结果，按关键维度分组去重，输出最终对比报表</li>
</ul>
<p>需要说明的是，这个业务的补值以及数据扩充逻辑包含<strong>30+个业务分支需要验证</strong>，<strong>快照表达到亿级数据量</strong>，属于相当复杂的SQL需求。</p>
<h3 id="实现的整体过程"><a href="#实现的整体过程" class="headerlink" title="实现的整体过程"></a>实现的整体过程</h3><h4 id="第一阶段：从零开始的AI辅助SQL开发"><a href="#第一阶段：从零开始的AI辅助SQL开发" class="headerlink" title="第一阶段：从零开始的AI辅助SQL开发"></a>第一阶段：从零开始的AI辅助SQL开发</h4><p>在没有相关业务上下文的情况下，我开始尝试使用AI进行复杂SQL开发：</p>
<ol>
<li><strong>业务理解</strong>：作为一个已经2年未完成过复杂SQL需求的开发者，面对复杂数据场景时，AI帮助我快速验证了业务需求中的数据逻辑，厘清业务和技术思路。</li>
<li><strong>SQL技术方案生成</strong>：<ul>
<li>初期完全依赖AI生成，但由于业务逻辑极其复杂，几乎不可能一次性构思完整方案</li>
<li>通过理解AI生成代码的思路，逐步形成了粗略的技术框架：<strong>预处理数据→扩展数据→补充数据→整理输出</strong></li>
<li>每个高层任务下隐藏着众多细节，例如如何Join表、如何处理匹配与未匹配数据等</li>
<li>经过多次调整，AI最终生成了1157行的SQL，但放入BigQuery后出现大量报错</li>
<li>修复报错后发现逻辑仍有问题，于是想到使用AI生成测试数据集进行验证</li>
</ul>
</li>
</ol>
<p>虽然SQL生成效果不理想，但这一阶段的最大收获是建立了”<strong>编写提示词→生成SQL→基于提示词生成测试数据→验证</strong>“的完整流程，为后续工作奠定了基础。</p>
<p><img src="/../images/sql_related_prompt_v1.png" alt="sql_related_prompt_v1.png"><br><img src="/../images/sql_result_v1.png" alt="sql_result_v1.png"></p>
<h4 id="第二阶段：理解业务本质，重构解决方案"><a href="#第二阶段：理解业务本质，重构解决方案" class="headerlink" title="第二阶段：理解业务本质，重构解决方案"></a>第二阶段：理解业务本质，重构解决方案</h4><p>完全理解业务逻辑后，我重新审视了这个复杂需求：</p>
<ol>
<li><strong>把握本质</strong>：认识到这个需求本质上是将两张表的数据经处理后进行对比，理解了这一点后，结合第一阶段的经验，对问题进行了系统性拆解。</li>
<li><strong>结构化实现</strong>：<ul>
<li>遵循”<strong>本质决定边界，特征决定细节</strong>“的原则，将大任务分解为相对简单的单元</li>
<li>每个单元只专注一件事，通过PDD方法论将每个实现任务用提示词呈现</li>
<li>因为任务简化，单元内做的事情相对单一，AI的幻觉大幅减少，提示词完成后SQL能较准确生成</li>
<li>得益于第一阶段建立的验证流程，可以快速验证每个任务的实现</li>
</ul>
</li>
<li><strong>成果验证</strong>：<ul>
<li>最终生成435行SQL，思路清晰流畅，自己也能轻易理解</li>
<li>在BigQuery上基本一次运行成功，没有额外语法错误</li>
<li>完成了大部分逻辑分支的验证测试</li>
</ul>
</li>
</ol>
<p>然而，当使用真实数据（亿级数量级）验证时，SQL在5分钟内无法完成运行，中间结果达到268+GB，显然需要进一步优化。</p>
<p><img src="/../images/sql_related_prompt_v2_1.png" alt="sql_related_prompt_v1_1.png"><img src="/../images/sql_related_prompt_v2_2.png" alt="sql_related_prompt_v1_2.png"><br><img src="/../images/SQL_processing_result.png" alt="SQL_processing_result.png"></p>
<h4 id="第三阶段：性能优化"><a href="#第三阶段：性能优化" class="headerlink" title="第三阶段：性能优化"></a>第三阶段：性能优化</h4><p>面对性能问题，我采取了以下步骤：</p>
<ol>
<li><strong>根因分析</strong>：请教团队中数据领域经验丰富的同事，发现主要问题是在使用AI生成SQL时忽略了数据量级（线上数据达到亿级），直接对大表进行多次Join操作。</li>
<li><strong>优化方向</strong>：<ul>
<li>大表尽量只Join一次，一次获取所有需要的结果</li>
<li>与大表Join前先过滤数据，减小驱动表尺寸</li>
<li>优化Join类型，根据需要合理使用Inner Join和Left Join</li>
<li>分步获取需要的值，减少连续Join，只选取必要字段，减少传输数据量</li>
</ul>
</li>
<li><strong>效果显著</strong>：<ul>
<li>从”5分钟无结果，涉及到的数据几百GB”</li>
<li>优化到”37秒完成，最终结果仅3.7GB”</li>
</ul>
</li>
</ol>
<p><img src="/../images/sql_processing_result_final.png" alt="sql_processing_result_final.png"></p>
<p>在这一个过程中，当确定优化方向后，补值逻辑其实是需要重写的，但是通过步骤一和步骤二的探索后，在Data领域稳定生成期望sql的模式已经建立了，所以，即使重新写也没关系，这个过程非常快速的完成了。后续还有进行分之逻辑修复的处理，本质上步骤类似，就不在这里进行展示了。</p>
<h3 id="结构化提示驱动开发-PDD-在数据领域的应用方法论"><a href="#结构化提示驱动开发-PDD-在数据领域的应用方法论" class="headerlink" title="结构化提示驱动开发(PDD)在数据领域的应用方法论"></a>结构化提示驱动开发(PDD)在数据领域的应用方法论</h3><p>通过这次项目实践，我总结了PDD在数据领域特别是SQL开发中的应用方法论，希望能为类似场景下的开发提供参考。</p>
<h4 id="PDD在SQL开发中的核心结论"><a href="#PDD在SQL开发中的核心结论" class="headerlink" title="PDD在SQL开发中的核心结论"></a>PDD在SQL开发中的核心结论</h4><p><strong>场景适用性</strong></p>
<ul>
<li><strong>简单场景</strong>：<ul>
<li>PDD可直接生成SQL脚本，无需过多调整</li>
<li>适用于基础查询（过滤、聚合等）</li>
</ul>
</li>
<li><strong>复杂场景</strong>：<ul>
<li>需通过结构化验证和迭代优化实现</li>
<li><strong>关键步骤</strong>：<ul>
<li><strong>定义完成标准（DOD）</strong>：提前明确验收标准（如输出格式、性能指标），作为初版SQL的验证基准</li>
<li><strong>迭代优化</strong>：根据DOD识别问题（逻辑错误、边缘场景），逐步调整提示词，生成新SQL直至通过所有测试用例</li>
<li><strong>性能调优</strong>：优先小步重构（如根据中间表逐步调整优化），避免大规模重写，降低风险并保持可读性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="PDD在Data领域的-High-Level-实践流程"><a href="#PDD在Data领域的-High-Level-实践流程" class="headerlink" title="PDD在Data领域的 High Level 实践流程"></a>PDD在Data领域的 High Level 实践流程</h4><ul>
<li><strong>人类输入</strong>：结构化提示（业务逻辑、数据模型、约束条件等）</li>
<li><strong>AI输出</strong>：初版SQL</li>
<li><strong>验证</strong>：对照DOD检查功能正确性与性能</li>
<li><strong>优化</strong>：根据问题调整提示词（如澄清模糊逻辑）</li>
<li><strong>调优</strong>：结合AI建议优化（如索引策略、执行计划分析）</li>
</ul>
<h4 id="实施建议与最佳实践"><a href="#实施建议与最佳实践" class="headerlink" title="实施建议与最佳实践"></a>实施建议与最佳实践</h4><ol>
<li><strong>在正式进行prompt的编写之前，明确业务需求</strong><ul>
<li>使用文档或其他非技术性的合适方式，与业务人员达成一致</li>
<li>定义清楚DOD，避免边做边确认需求（非常重要，尤其是在SQL场景下，能提高验证阶段性目标的效率）</li>
<li>当需求明确后，可以更有效地避免边做边确认需求的情况</li>
<li>如遇edge case，回顾业务梳理文档，将其添加到结构化prompt的相应任务中</li>
</ul>
</li>
<li><strong>基于业务需求文档确定技术解决方案框架</strong><ul>
<li><strong>实现方案清晰时</strong>：<ul>
<li>定义实现需求的抽象步骤</li>
<li>根据抽象步骤，细化每个任务</li>
<li>可一个任务一个任务地调试，而不必一次性全部生成</li>
<li>当第一个任务稳定后，使用相同模式编写其余任务的提示词</li>
</ul>
</li>
<li><strong>实现方案不清晰时</strong>：<ul>
<li>基于梳理好的数据查询逻辑与AI沟通，获取可行的抽象步骤</li>
<li>结合个人理解确定最终实现方案的抽象步骤</li>
<li>基于实现方案清晰的步骤，使用结构化提示词生成SQL代码</li>
</ul>
</li>
</ul>
</li>
<li><strong>初版提示词生成与细节补充</strong><ul>
<li>首次生成的SQL可能有很多不尽人意之处，需要耐心调整</li>
<li>遇到生成不符合期望的SQL时，找到对应的任务提示词区域，添加更详细的细节说明</li>
<li>可结合专业推理型模型，获取SQL优化建议或实现方案的改进</li>
</ul>
</li>
<li><strong>总体策略</strong><ul>
<li>若对实现细节非常清楚：可直接手写SQL，完成后用AI按照PDD方法论组织提示词的模式，总结实现方案更新到prompt中</li>
<li>若对技术栈实现细节不清楚：先用自然语言描述逻辑和框架，让AI基于prompt生成，调试定版后再总结更新回prompt</li>
<li>更新prompt的目的是记录与AI达成一致的内容，便于今后遇到相似场景时直接复用，减少探索成本</li>
</ul>
</li>
</ol>
<h4 id="复杂场景下的人员能力要求"><a href="#复杂场景下的人员能力要求" class="headerlink" title="复杂场景下的人员能力要求"></a>复杂场景下的人员能力要求</h4><p><strong>核心能力</strong></p>
<ul>
<li><strong>熟练掌握PDD理论</strong>：<ul>
<li><strong>关键技能</strong>：识别并消除AI幻觉</li>
<li><strong>示例</strong>：修正不符合业务规则的JOIN逻辑</li>
</ul>
</li>
<li><strong>问题分析与需求结构化能力</strong>：<ul>
<li><strong>业务理解</strong>：将模糊需求转化为精准技术规范</li>
<li><strong>信息溯源</strong>：定位数据源（如数据字典、领域专家）</li>
<li><strong>方案设计</strong>：模块化实现计划（如拆分复杂逻辑为中间表）</li>
</ul>
</li>
<li><strong>结构化信息管理能力</strong>：<ul>
<li><strong>上下文组织</strong>：将非结构化需求结构化</li>
<li><strong>提示词工程</strong>：编写清晰且灵活的结构化提示词</li>
</ul>
</li>
<li><strong>AI认知能力</strong>：<ul>
<li><strong>优劣判断</strong>：<ul>
<li><strong>优势</strong>：快速原型设计、模式识别</li>
<li><strong>劣势</strong>：处理边缘场景、上下文歧义</li>
</ul>
</li>
<li><strong>工具选择</strong>：<ul>
<li>技术任务使用垂直领域AI（如代码生成专用模型）</li>
<li>通用AI用于头脑风暴或文档生成</li>
</ul>
</li>
<li><strong>批判性验证</strong>：<ul>
<li><strong>乐观</strong>：相信通过迭代可达成目标</li>
<li><strong>谨慎</strong>：严格基于DOD和人工复查验证结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结与未来展望"><a href="#总结与未来展望" class="headerlink" title="总结与未来展望"></a>总结与未来展望</h3><p>这次PDD在数据领域的应用实践让我获得了以下关键洞见：</p>
<ol>
<li><strong>明确定义完成标准(DOD)非常重要</strong>：清晰的目标指引整个开发过程。</li>
<li><strong>熟练运用PDD原则应对新场景</strong>：即使在未探索的领域，坚持PDD的指导原则，最终都能找到解决方案，同时积累该场景的PDD应用经验。</li>
<li><strong>持续探索与解决问题的态度</strong>：遇到问题时具体分析，逐步攻破，而非轻易放弃；设定时间限制，及时寻求适当帮助。</li>
<li><strong>PDD效能提升需要积累</strong>：在新领域首次探索时，不要过分期待AI带来即时效率提升，只有走通流程、固化模式后，通过不断积累和训练，<strong>效能</strong>（与效率要区分开）才会显著提高。</li>
<li><strong>可持续能力提升</strong>：在AIFSD(AI-First Software Development)模式下，我们追求的不仅是短期效率提升，更注重通过持续积累实现个人能力的全面增长。当我们不断实践统一方法论时，经验积累与认知提升相辅相成，从而增强解决问题的综合能力。这种个人能力的持续提升，将使我们与AI的协作越发高效和互补，形成良性循环。</li>
</ol>
<p><img src="/../images/cognitive_improve_process_by_using_AI.png" alt="cognitive_improve_process_by_using_AI.png"></p>
<p>通过这次实践，验证了PDD方法论在数据领域特别是复杂SQL场景下的适用性，并提炼出了一套在Data领域写复杂SQL的可重复使用的可行性路径（<a target="_blank" rel="noopener" href="https://github.com/gszhangwei/structured-prompts-driven-development/blob/main/data/en/DATA-PROCESSING-TEMPLATE-EN.md">点击查看模板</a>）。随着更多项目实践和经验积累，相信PDD方法论还将不断完善，为软件开发领域带来更高的效率和质量提升。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/04/10/AI-workflows-improve-software-development-efficiencyt-en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/10/AI-workflows-improve-software-development-efficiencyt-en/" class="post-title-link" itemprop="url">Structured Prompt-Driven Development Workflow - Transforming Software Development from 2 Days to 1 Hour</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-04-10 12:00:00 / 修改时间：12:05:27" itemprop="dateCreated datePublished" datetime="2025-04-10T12:00:00+08:00">2025-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Since the publication of <a target="_blank" rel="noopener" href="https://central.thoughtworks.net/blogs/ls/content/136117101053029/structured-prompts-driven-development-1781b9ae-3d4b-458d-8b8b-0265fa34e1cb">Structured Prompt-Driven Development in Practice</a>, the feedback I’ve received highlights <strong>two core needs</strong>: <strong>lowering the methodology application threshold</strong> and <strong>providing directly reusable practice templates</strong>.</p>
<p>As a practitioner who has experienced the transition from traditional development to AI-assisted programming, I deeply feel that software development is currently undergoing a dual transformation: accelerating industry iteration and an efficiency revolution triggered by generative AI. When AI-generated code acceptance rates jump from 30% to 95%, this signals a fundamental paradigm shift in development.</p>
<p>Facing the reality that methodology is <strong>“easy to understand but difficult to implement”</strong>, could we adopt a progressive model of <strong>“use-understand-innovate”</strong> to help developers naturally master methodological essentials while achieving immediate results?</p>
<p>In fact, the <strong>universal solution layer</strong> in the structured prompt-driven development methodology can serve as the key breakthrough - <strong>building reusable abstract solution templates</strong>.</p>
<p>[Prompts Strategy Image Placeholder]</p>
<p>Our practicing confirms that these templated solutions can reduce the time novices need to build effective prompts <strong>from 2 hours to 30 minutes</strong>, with prompt output quality improving by over 50%.</p>
<p>This article introduces a battle-tested AI-enhanced software development workflow that has been applied and verified in over a hundred actual development tasks. Through a systematic 5-stage, 14-step process, we’ve observed significant efficiency improvements: development tasks that traditionally required 2 days can now be completed in under 1 hour, achieving nearly 16x speed improvement in optimal cases. This workflow integrates structured prompt engineering with software development best practices, suitable for developers at all experience levels—whether you’re new to AI-assisted development or an experienced engineer seeking efficiency breakthroughs—I hope everyone can derive substantial value from it, significantly accelerating development pace while maintaining or even improving code quality.</p>
<h2 id="Background-and-Tool-Ecosystem"><a href="#Background-and-Tool-Ecosystem" class="headerlink" title="Background and Tool Ecosystem"></a>Background and Tool Ecosystem</h2><h3 id="Limitations-of-Traditional-Development-Processes"><a href="#Limitations-of-Traditional-Development-Processes" class="headerlink" title="Limitations of Traditional Development Processes"></a>Limitations of Traditional Development Processes</h3><p>Traditional software development processes typically include requirements analysis, design, coding, testing, and deployment. Although agile methodologies have improved iteration speed, developers still need to manually complete numerous repetitive tasks: writing boilerplate code, building test cases, handling edge conditions, etc. While necessary, these tasks consume time that could be used for innovation and solving core business problems.</p>
<h3 id="Core-Tools-Introduction"><a href="#Core-Tools-Introduction" class="headerlink" title="Core Tools Introduction"></a>Core Tools Introduction</h3><p>My AI-assisted development workflow is primarily built on the following tools:</p>
<ul>
<li><strong>Cursor</strong>: AI-driven code editor supporting code generation, completion, refactoring, and intelligent dialogue</li>
<li><strong>Jira MCP Server</strong>: For obtaining and managing business requirements</li>
<li><strong>Aupro</strong>: Our engineering practice governance platform, including MCP end, page end, and server end, enabling technology governance teams to establish and share code delivery standards so AI code assistants can generate high-quality code. (<strong>For teams without similar platforms, lightweight alternatives can be adopted</strong>: organizing structured prompt templates in local version control systems through structured folders and clear naming conventions to achieve template management, which can still yield significant benefits)</li>
<li><strong>Various testing frameworks</strong>: Such as JUnit 5 (Jupiter), etc., working with workflows to implement automated testing</li>
</ul>
<p>[AI Development Process Abstract Image Placeholder]</p>
<h2 id="AI-Enhanced-Software-Development-Workflow-Detailed-Analysis-of-5-Stages-and-14-Steps"><a href="#AI-Enhanced-Software-Development-Workflow-Detailed-Analysis-of-5-Stages-and-14-Steps" class="headerlink" title="AI-Enhanced Software Development Workflow: Detailed Analysis of 5 Stages and 14 Steps"></a>AI-Enhanced Software Development Workflow: Detailed Analysis of 5 Stages and 14 Steps</h2><h3 id="Requirements-Analysis-and-Planning-Stage"><a href="#Requirements-Analysis-and-Planning-Stage" class="headerlink" title="Requirements Analysis and Planning Stage"></a>Requirements Analysis and Planning Stage</h3><ul>
<li><strong>Requirements Analysis and Solution Conceptualization</strong><ul>
<li>First, retrieve historical implementations and best practices for similar tasks to establish a knowledge base</li>
<li>Collaborate with AI to explore technical solutions, quickly evaluating feasibility and tradeoffs of different implementation paths</li>
<li>Clearly define specific problems AI needs to solve, setting expected outcomes and success metrics</li>
<li>This step lays the foundation for the entire development process; clear problem definition makes subsequent AI generation more precise and efficient</li>
</ul>
</li>
<li><strong>Requirements Structuring</strong><ul>
<li>Leverage AI’s natural language processing capabilities to convert business requirements into structured user stories</li>
<li>Ensure requirement descriptions are complete and include clear acceptance criteria and expected results</li>
<li>This step transforms abstract business concepts into clear technical tasks, reducing requirement understanding deviations</li>
</ul>
</li>
</ul>
<h3 id="Design-and-Solution-Definition-Stage"><a href="#Design-and-Solution-Definition-Stage" class="headerlink" title="Design and Solution Definition Stage"></a>Design and Solution Definition Stage</h3><ul>
<li><strong>Implementation Solution Design</strong><ul>
<li>Apply pre-summarized solution templates to generate structured prompts</li>
<li>Clearly define technical path, data structures, interface definitions, and key business logic implementation details</li>
<li>Design staged implementation strategies for complex functionalities, breaking large tasks into manageable small modules</li>
<li>High-quality prompts are key to obtaining high-quality code output, requiring a combination of business knowledge and technical experience</li>
</ul>
</li>
<li><strong>Solution Detail Adjustment and Optimization</strong><ul>
<li>Comprehensively evaluate quality, completeness, and technical feasibility of generated prompts</li>
<li>Analyze whether the solution considers scalability, performance, and long-term maintenance requirements</li>
<li>Adjust implementation strategies based on business requirements and technical constraints, anticipating potential problems</li>
<li>This step is equivalent to architecture review in traditional development, ensuring implementation direction is correct</li>
</ul>
</li>
</ul>
<h3 id="Code-Development-and-Implementation-Stage"><a href="#Code-Development-and-Implementation-Stage" class="headerlink" title="Code Development and Implementation Stage"></a>Code Development and Implementation Stage</h3><ul>
<li><strong>Code Generation and Initial Verification</strong><ul>
<li>Use optimized prompts to generate implementation code, including basic architecture and core functionality</li>
<li>Perform quick validation to check if basic functions and code structure meet expectations</li>
<li>Evaluate whether generated code follows project coding standards and best practices</li>
</ul>
</li>
<li><strong>Code Review and Prompt Fine-tuning</strong><ul>
<li>Carefully examine code quality, performance, security, and boundary handling</li>
<li>Identify potential “code smells” and optimization points in the code</li>
<li>Make targeted adjustments to prompts to address discovered issues, providing clear correction guidance</li>
<li>This is an iterative optimization process, continuously improving code quality through precise prompt adjustments</li>
</ul>
</li>
<li><strong>Final Code Generation</strong><ul>
<li>Use finalized prompts to regenerate optimized implementation code</li>
<li>Ensure code style consistency, readability, and adherence to best practices</li>
<li>The finalized prompts incorporate optimization experiences from previous iterations, significantly improving generated code quality</li>
</ul>
</li>
<li><strong>Functionality Verification</strong><ul>
<li>Manually verify core functionality and boundary scenarios to ensure functional completeness</li>
<li>Perform static code analysis to check code quality metrics and potential issues</li>
<li>Verify code compatibility and integration points with existing systems</li>
<li>The verification process checks both functional correctness and code maintainability and performance optimization space</li>
</ul>
</li>
</ul>
<h3 id="Testing-and-Quality-Assurance-Stage"><a href="#Testing-and-Quality-Assurance-Stage" class="headerlink" title="Testing and Quality Assurance Stage"></a>Testing and Quality Assurance Stage</h3><ul>
<li><strong>Test Prompt Generation</strong><ul>
<li>Based on solution implementation detail prompts, combined with summarized test prompt templates, generate structured test cases</li>
<li>Ensure tests cover normal processes, boundary conditions, and exception handling scenarios</li>
<li>Good test design can prevent future regression issues and serve as living documentation of code functionality</li>
</ul>
</li>
<li><strong>Test Planning Confirmation</strong><ul>
<li>Review completeness and appropriateness of test scenarios to ensure comprehensive test coverage</li>
<li>Ensure tests cover not only normal situations but also exception handling and various boundary conditions</li>
</ul>
</li>
<li><strong>Test Code Generation and Execution</strong><ul>
<li>Use test prompts to generate automated test code, ensuring test code quality</li>
<li>Execute automated tests and collect detailed results, analyzing test coverage</li>
<li>Verify whether tests can effectively discover potential problems and boundary situations</li>
<li>AI-generated tests are often more comprehensive than manually written tests, covering more boundary situations and exception paths</li>
</ul>
</li>
<li><strong>Problem Fixing and Iteration</strong><ul>
<li>Categorize problem causes based on test results and establish priority fix order</li>
<li>Make targeted fixes, distinguishing handling strategies: <strong>For uncovered boundary scenarios</strong>, modify implementation code and update corresponding prompts; <strong>For test data issues</strong>, optimize test data without changing implementation logic</li>
<li>Repeat testing until all tests pass, ensuring code quality and stability</li>
<li>Record experiences and discoveries during the fixing process as material for prompt template optimization</li>
</ul>
</li>
</ul>
<h3 id="Delivery-and-Knowledge-Management-Stage"><a href="#Delivery-and-Knowledge-Management-Stage" class="headerlink" title="Delivery and Knowledge Management Stage"></a>Delivery and Knowledge Management Stage</h3><ul>
<li><strong>Integration and Submission</strong><ul>
<li>Ensure code compatibility with existing systems, verifying integration points work properly</li>
<li>Submit code and structured prompts solutions to facilitate team understanding of development ideas</li>
</ul>
</li>
<li><strong>Knowledge Precipitation</strong><ul>
<li>Extract effective prompt patterns and update team template library, forming reusable assets</li>
<li>Summarize lessons learned, recording successful strategies and challenges encountered</li>
<li>Share innovative practices and technological breakthroughs, promoting overall team capability improvement</li>
</ul>
</li>
</ul>
<h2 id="Core-Advantages-and-Potential-Challenges"><a href="#Core-Advantages-and-Potential-Challenges" class="headerlink" title="Core Advantages and Potential Challenges"></a>Core Advantages and Potential Challenges</h2><ul>
<li><p><strong>Core Advantages:</strong></p>
<ul>
<li><strong>Structural Benefits</strong>: Structured prompts implement a systematic approach to code generation, creating a more organized and predictable development process while providing a stable framework for consistency.</li>
<li><strong>Standardization Improvements</strong>: The integration of templates with AI generation techniques significantly enhances both code and test case consistency and completeness, effectively minimizing variations that typically arise from manual development.</li>
<li><strong>Quality Assurance Framework</strong>: A comprehensive multi-level verification system—spanning from design conception through implementation to functional testing—creates a complete quality control loop that thoroughly ensures code reliability at every stage.</li>
<li><strong>Significant Efficiency Gains</strong>: Through this optimized methodology, development efficiency achieves remarkable improvement, transforming work that traditionally required two full days into tasks completable within a single hour—representing an approximate 95% reduction in time investment.</li>
</ul>
</li>
<li><p><strong>Potential Challenges:</strong></p>
<ul>
<li><strong>Skill Requirement</strong>: Effective prompt engineering mastery requires both technical skill depth and a persistent refinement mindset</li>
<li><strong>Quality Standard</strong>: It is essential to ensure high-quality structured-prompt documentation and maintainable generated code</li>
<li><strong>AI Dependency Risk</strong>: Over-reliance dependence on AI may lead to insufficient understanding of generated code</li>
</ul>
</li>
</ul>
<h2 id="Practical-Case"><a href="#Practical-Case" class="headerlink" title="Practical Case"></a>Practical Case</h2><p>Theory needs verification through practice. To better demonstrate the methodology and workflow’s actual effects, I’ve recorded a complete development example video. Welcome to watch and provide valuable suggestions.<br>[Video Placeholder]</p>
<p>The process shown in the video is mainly summarized as follows:<br>[Sequence Diagram Placeholder]</p>
<h2 id="Best-Practices-and-Experience-Summary"><a href="#Best-Practices-and-Experience-Summary" class="headerlink" title="Best Practices and Experience Summary"></a>Best Practices and Experience Summary</h2><p><strong>Effective prompts</strong> are the core of the entire workflow. Here are some key techniques:</p>
<ul>
<li><strong>Abstract first, then concrete</strong>: Start with task decomposition and framework building, rather than getting bogged down in details initially. First clearly define the abstract steps for implementing functionality and relationships between these steps, then elaborate on each abstract step according to effective prompt construction principles. This “top-down” approach ensures generated code has reasonable structure and clear layers.</li>
<li><strong>Structured information provision</strong>: Describe solutions following structured prompt-driven development principles, clarifying code generation paths. Structured prompts not only make it easier for AI to understand development intentions but also make subsequent iterations and adjustments clearer and more controllable, laying the foundation for code quality.</li>
<li><strong>Context association management</strong>: Include necessary association information in prompts, such as inheritance relationships between business models and call relationships between framework layers. Good context association enables AI to understand overall system architecture, generating code that conforms to established architectural styles and design philosophies, reducing later refactoring needs.</li>
<li><strong>Prompt governance</strong>: Manage effective prompts to form a reusable template library. As projects progress, continuously accumulate and optimize prompt templates, gradually forming a prompt asset library suitable for team and project characteristics, improving long-term efficiency.</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><strong>AI-assisted development</strong> is not just introducing efficiency tools, but <strong>a transformation of software development paradigms</strong>. Through the AI-assisted development workflow introduced in this article, developers can achieve efficient collaboration with AI, delegating repetitive work to AI while <strong>focusing</strong> on more <strong>creative</strong> and <strong>strategic</strong> tasks.</p>
<p>Practice has proven that using this workflow, after becoming proficient, <strong>development efficiency can improve by at least 3 times</strong> while maintaining or even improving code quality. With continuous advancement of AI technology, there’s even more room for efficiency improvement. For individual developers and teams, now is the best time to embrace this transformation.</p>
<p>Mastering AI-assisted development is not about replacing developers, but redefining how we work. The real value lies in human-machine collaboration—AI handles execution and assistance, while humans handle innovation and decision-making. Future top developers will be compound talents who both master technology itself and can effectively guide AI to complete tasks.</p>
<h2 id="Some-Thoughts-on-the-Essence-of-Code"><a href="#Some-Thoughts-on-the-Essence-of-Code" class="headerlink" title="Some Thoughts on the Essence of Code"></a>Some Thoughts on the Essence of Code</h2><p>This transformation also prompts me to rethink the essence of code: <strong>Code itself is a symbolic expression of human intent, constantly evolving with technological development.</strong> From punched paper tapes to assembly language, to high-level languages like C++, Python, Java, etc., each technological innovation has expanded the boundaries of <strong>“what is code.”</strong> Today, as AI can precisely understand human language and intent through specific methods, <strong>natural language programming</strong> becomes a <strong>new stage</strong> in programming paradigms’ natural evolution—not replacing traditional programming but extending it.</p>
<p>Different programming paradigms each have their value and scenarios, just as in transportation’s historical evolution, new technology doesn’t mean complete elimination of old technology. Forward-thinking developers will be inclusive—mastering traditional programming’s rigorous structure while using that experience to explore more possibilities in prompt engineering, perhaps even developing more direct human-machine interaction methods in the future. In technological change waves, understanding essential principles behind technology and maintaining an open learning attitude are far more important than adhering to specific implementation forms—<strong>Code forms will continue to iterate, while the spirit of innovation remains constant.</strong></p>
<p>Let us actively embrace this transformation, rethink the essence of software development, and create greater value in the new era of human-machine collaboration.</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><p>As a practical tool for this methodology, we provide a set of battle-tested prompt templates covering API CRUD operations and accompanying test strategies (click this link to view the complete template library). These templates can not only be used directly in daily development but also serve as examples for learning structured prompt engineering.</p>
<p>We sincerely invite all developers to innovate and expand based on their own project needs while using these basic templates, jointly promoting the continuous evolution of this methodology.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/03/21/AI-workflows-improve-software-development-efficiencyt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/21/AI-workflows-improve-software-development-efficiencyt/" class="post-title-link" itemprop="url">AI-Workflow革命：2天任务仅需50分钟！</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-21 17:00:00" itemprop="dateCreated datePublished" datetime="2025-03-21T17:00:00+08:00">2025-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-31 17:57:46" itemprop="dateModified" datetime="2025-03-31T17:57:46+08:00">2025-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Hade1vZDIRMwbTyZxB0-Hg">《结构化提示词驱动开发实践》</a>发布以来，我收到的反馈中有两个核心诉求格外突出：降低方法论应用门槛和提供可直接复用的实践模板。<br>作为亲历从传统开发到AI辅助编程转变的实践者，我深感当下软件开发正经历双重变革：行业迭代加速与生成式AI引发的效率革命。当AI生成代码的通过率从30%跃升至95%，这预示着开发范式的根本性转变。<br>面对方法论”知易行难”的现实，是否可以通过”<strong>使用-理解-创新</strong>“的渐进模式，让开发者在获得即时成果的同时自然习得方法论精髓？<br>其实，在《结构化提示词驱动开发实践》方法论中的<strong>通用方案层</strong>恰好可作为破局关键 - <strong>构建可重复使用的抽象的解决方案模板</strong>。<br><br><img src="/../images/Prompts_engineering_strategies.png" alt="Prompts_engineering_strategies.png"><br><br>实测表明，这种模板化方案将新手<strong>构建有效Prompt</strong>的时间<strong>从2小时缩短至30分钟</strong>，Prompt输出质量提升50%以上。<br>本文将分享一套经过50余个开发任务验证的AI增强工作流，通过5阶段14个精炼步骤，将传统开发中耗时2天的任务最短压缩至55分钟内完成，效率最高提升16倍。无论你是AI开发新人还是资深工程师，希望这套融合结构化思维与AI辅助的工作流都能为你开启效率新维度。</p>
<h2 id="背景与工具生态"><a href="#背景与工具生态" class="headerlink" title="背景与工具生态"></a><strong>背景与工具生态</strong></h2><h3 id="传统开发流程的局限性"><a href="#传统开发流程的局限性" class="headerlink" title="传统开发流程的局限性"></a><strong>传统开发流程的局限性</strong></h3><p>传统软件开发流程通常包含需求分析、设计、编码、测试和部署等环节。尽管敏捷方法论提高了迭代速度，但开发者仍需手动完成大量重复性工作：编写样板代码、构建测试用例、处理边界条件等。这些任务虽然必要，却占用了大量本可用于创新和解决核心业务问题的时间。</p>
<h3 id="核心工具介绍"><a href="#核心工具介绍" class="headerlink" title="核心工具介绍"></a><strong>核心工具介绍</strong></h3><p>我的AI辅助开发工作流主要基于以下工具构建：</p>
<ul>
<li><strong>Cursor</strong>：AI驱动的代码编辑器，支持代码补全、重构和智能对话</li>
<li><strong>Jira MCP Server</strong>：获取和管理业务需求的项目管理工具</li>
<li><strong>Aupro</strong>：我们构建的工程实践治理平台，使技术治理团队能够制定和共享代码交付标准，从而使AI代码助手能够生成高质量的代码。（如果暂时没有这样的平台也不要紧，可以手动将模板放到本地管理起来）</li>
<li><strong>各类测试框架</strong>：例如JUnit 5 (Jupiter)等，配合工作流实现自动化测试</li>
</ul>
<h3 id="AI增强软件开发工作流方案详解"><a href="#AI增强软件开发工作流方案详解" class="headerlink" title="AI增强软件开发工作流方案详解"></a><strong>AI增强软件开发工作流方案详解</strong></h3><p>这套AI增强软件开发工作流是一个系统化的14步流程，将AI工具融入软件开发的各个环节，从技术需求分析到代码提交。通过实践证明，这套工作流可以将原本需要两天完成的工作量（如创建一个根据给出的动态查询条件，进行资源分页查询API及其完整测试场景）压缩到1小时内完成，效率提升显著。抽象的步骤如下：<br><br><img src="/../images/AI_workflow.png" alt="AI_workflow.png"></p>
<h3 id="AI增强软件开发工作流：5阶段14步骤详细解析"><a href="#AI增强软件开发工作流：5阶段14步骤详细解析" class="headerlink" title="AI增强软件开发工作流：5阶段14步骤详细解析"></a><strong>AI增强软件开发工作流：5阶段14步骤详细解析</strong></h3><ul>
<li><p><strong>需求分析与规划阶段</strong></p>
<ul>
<li>需求分析与解决方案构思<ul>
<li>首先检索相似任务的历史实现和最佳实践，建立知识基础</li>
<li>与AI协作探索技术方案，快速评估不同实现路径的可行性和优劣</li>
<li>明确定义AI需要解决的具体问题，设定预期成果和成功指标</li>
<li>这一步奠定了整个开发过程的基础，清晰的问题定义让后续AI生成更精准高效</li>
</ul>
</li>
<li>需求结构化<ul>
<li>利用AI的自然语言处理能力将业务需求转换为结构化用户故事</li>
<li>确保需求描述完整且包含明确的验收标准和预期结果</li>
<li>这一步将抽象业务概念转化为明确的技术任务，减少需求理解偏差</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>设计与方案定义阶段</strong></p>
<ul>
<li><p>实现方案设计</p>
<ul>
<li>应用预先总结的方案模板，生成结构化prompts</li>
<li>明确定义技术路径、数据结构、接口定义和关键业务逻辑实现细节</li>
<li>为复杂功能设计分层实现策略，将大任务分解为可管理的小模块</li>
<li>高质量的prompt是获得高质量代码输出的关键，需结合业务知识和技术经验设计</li>
</ul>
</li>
<li><p>方案细节调整与优化</p>
<ul>
<li>全面评估生成的prompts质量、完整性和技术可行性</li>
<li>分析方案是否考虑了可扩展性、性能和长期维护需求</li>
<li>根据业务需求和技术限制调整实现策略，预见潜在问题</li>
<li>这一步相当于传统开发中的架构评审，确保实现方向正确无误</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>代码开发与实现阶段</strong></p>
<ul>
<li><p>代码生成与初步验证</p>
<ul>
<li>利用优化后的prompts生成实现代码，包括基础架构和核心功能</li>
<li>通过快速验证检查基本功能和代码结构是否符合预期</li>
<li>评估生成代码是否遵循项目编码规范和最佳实践</li>
</ul>
</li>
<li><p>代码审核与prompt微调</p>
<ul>
<li>细致检查代码质量、性能、安全性和边界处理</li>
<li>识别代码中的潜在”代码异味”(Code Smells)和可优化点</li>
<li>针对性调整prompt以解决发现的问题，进行明确的修正指导</li>
<li>这是一个迭代优化过程，通过prompt精确调整不断提高代码质量</li>
</ul>
</li>
<li><p>代码最终生成</p>
<ul>
<li>使用定稿prompts重新生成优化后的实现代码</li>
<li>确保代码风格一致性、可读性和最佳实践遵循</li>
<li>验证代码是否包含适当的注释和文档化</li>
<li>定稿的prompt包含前几轮迭代中的优化经验，生成的代码质量显著提高</li>
</ul>
</li>
<li><p>功能验证</p>
<ul>
<li>手动验证核心功能和边界场景，确保功能完整性</li>
<li>执行静态代码分析，检查代码质量指标和潜在问题</li>
<li>验证代码与现有系统的兼容性和集成点</li>
<li>验证过程既检查功能正确性，也关注代码可维护性和性能优化空间</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>测试与质量保障阶段</strong></p>
<ul>
<li><p>测试设计</p>
<ul>
<li>基于<strong>解决方案实现细节prompts</strong>，结合总结的测试Prompt模板，生成结构化测试用例</li>
<li>确保测试覆盖正常流程、边界条件和异常处理场景</li>
<li>良好的测试设计能防止未来的回归问题，并作为代码功能的活文档</li>
</ul>
</li>
<li><p>测试规划确认</p>
<ul>
<li>审核测试场景的完整性和适当性，确保测试范围全面</li>
<li>确保测试不仅覆盖正常情况，也包含异常处理和各种边界条件</li>
</ul>
</li>
<li><p>测试代码生成与执行</p>
<ul>
<li>使用测试prompts生成自动化测试代码，确保测试代码质量</li>
<li>执行自动化测试并收集详细结果，分析测试覆盖率</li>
<li>验证测试是否能有效发现潜在问题和边界情况</li>
<li>AI生成的测试通常比手写测试更全面，能覆盖更多边界情况和异常路径</li>
</ul>
</li>
<li><p>问题修复与迭代</p>
<ul>
<li>根据测试结果分类问题原因，建立优先修复顺序</li>
<li>针对性进行修复，区分处理策略：<ul>
<li>对于未覆盖的边界场景，修改实现代码并更新对应prompts</li>
<li>对于测试数据问题，优化测试数据而不更改实现逻辑</li>
</ul>
</li>
<li>重复测试直至全部通过，确保代码质量和稳定性</li>
<li>记录修复过程中的经验和发现，作为prompt模版优化的素材</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>交付与知识管理阶段</strong></p>
<ul>
<li><p>集成与提交</p>
<ul>
<li>确保代码与现有系统完全兼容，验证所有集成点正常工作</li>
<li>提交代码和结构化Prompts方案，便于团队理解开发思路</li>
</ul>
</li>
<li><p>知识沉淀</p>
<ul>
<li>提炼有效prompt模式并更新团队模板库，形成可复用资产</li>
<li>总结经验教训，记录成功策略和遇到的挑战</li>
<li>分享创新实践和技术突破，促进团队整体能力提升</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="核心优势与潜在挑战"><a href="#核心优势与潜在挑战" class="headerlink" title="核心优势与潜在挑战"></a>核心优势与潜在挑战</h2><ul>
<li><strong>核心优势：</strong><ul>
<li>结构化流程使开发过程更加条理化和可预测</li>
<li>利用模板和AI生成提高了代码和测试的一致性和完整性</li>
<li>多层次验证确保代码质量，从设计到实现到测试全覆盖</li>
<li>显著提升效率，能将两天工作量缩减至一小时内完成</li>
</ul>
</li>
<li><strong>潜在挑战：</strong><ul>
<li>工作流效果很大程度依赖于AI响应的质量和精准度（目前claude-3.7-sonnet完全够用）</li>
<li>过度依赖AI可能导致对生成代码理解不足</li>
<li>Prompt工程需要专业技能和持续调优</li>
<li>需要注意生成代码的文档质量和可维护性</li>
</ul>
</li>
</ul>
<h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><p>理论终需实践验证。为了直观展示方法论的实际效果，我录制了完整的开发实例视频，欢迎各位观摩并提出宝贵意见。<br><a href="">点击观看视频演示</a>。视频中所展示的流程，整体如下所示：<br></p>
<div style="text-align: center;"><img src="../images/AI_workflow_sequence_diagram.png" alt="AI_workflow_sequence_diagram"></div>
<div style="text-align: center;"><span style="font-size: x-small; color: grey; ">Workflow关键的工作时序</span></div>

<h2 id="最佳实践与经验总结"><a href="#最佳实践与经验总结" class="headerlink" title="最佳实践与经验总结"></a>最佳实践与经验总结</h2><p>有效的prompt是整个工作流的核心，以下是一些关键技巧：</p>
<ul>
<li><strong>先抽象再具体</strong>：从框架搭建开始，而非一开始就陷入细节。先定义清楚实现功能的抽象步骤以及各步骤之间的关联关系，然后再根据这些抽象步骤，以有效构建提示词的指导思想，逐个进行细化。这种”自顶向下”的方法可以确保生成的代码结构合理、层次分明。</li>
<li><strong>结构化信息提供</strong>：以结构化提示词驱动开发的指导思想，描述解决方案，明确代码生成路径。结构化的prompt不仅使AI更易理解开发意图，也使后续的迭代和调整更加清晰可控，为代码质量奠定基础。</li>
<li><strong>上下文关联管理</strong>：在prompt中包含必要的关联信息，如业务建模之间的继承关系，使用的框架各层之间的调用关系等。良好的上下文关联使AI能够理解系统整体架构，生成符合既定架构风格和设计理念的代码，减少后期重构需求。</li>
<li><strong>版本控制</strong>：对有效prompt进行管理，形成可复用的模板库。随着项目进展，不断积累和优化prompt模板，逐步形成适合团队和项目特点的prompt资产库，提升长期效率。</li>
</ul>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>未来，我们将重点优化以下两个方面，充分发挥 AI 的能力：首先是提升 Workflow 的自动化程度；其次是构建 Prompt 自进化体系。该体系不仅依靠人工总结，更侧重于 AI 的智能学习，使其能基于优质 Prompt 实现方案，定期生成高质量模板。</p>
<ul>
<li><strong>自动化程度提升</strong>：通过自动化开发流程中的更多环节，例如基于需求自动创建 Jira Story、触发自动化代码审查等，来减少手动操作，提高流程一致性和效率。</li>
<li><strong>Prompt自进化体系</strong>：建立基于强化学习的 Prompt 模板演进体系，使 AI 能够学习现有模板库中的成功模式，并根据用户反馈和需求变化，自动优化模板并生成新的解决方案，形成持续改进的良性循环。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>AI辅助开发不仅是效率工具引入，更是软件开发范式的转变。通过本文介绍的AI辅助开发工作流，开发者可以实现与AI的高效协作，将重复性工作交由AI处理，而自身则专注于更具创造性和战略性的任务。<br>实践证明，采用这套工作流可以将开发效率提升至少3倍，同时保持甚至提高代码质量。随着AI技术的持续进步，这种效率提升还有更大空间。对于个人开发者和团队而言，现在正是拥抱这一变革的最佳时机。<br>掌握AI辅助开发不是要取代开发者的角色，而是重新定义我们的工作方式。真正的价值在于人机协作——AI负责执行和辅助，人类负责创新和决策。未来的顶尖开发者将是那些既精通技术本身，又能有效指导AI完成任务的复合型人才。<br>让我们积极拥抱这一变革，重新思考软件开发的本质，并在人机协作的新时代中创造更大的价值。</p>
<h2 id="最后，对于代码本质的一些思考"><a href="#最后，对于代码本质的一些思考" class="headerlink" title="最后，对于代码本质的一些思考"></a>最后，对于代码本质的一些思考</h2><p>代码的本质是人类意图的符号化表达，它是随着技术浪潮不断演化的。从早期的打孔纸带到汇编语言，从C++到Python、Java，每一次技术革新都拓展了我们对”何为代码”的理解边界。自然语言编程并非对传统编程的替代，而是编程范式自然演进的延伸——当AI能够精准理解人类意图与语境需求时，代码的表达方式自然而然地向更接近人类思维的形态靠拢。<br>不同的编程范式各有其价值与适用场景，就如同历史上各种交通工具的演进一样，新技术的出现并不意味着旧技术的全面淘汰。富有远见的开发者往往能够兼容并蓄：精通传统编程的严谨结构，同时探索prompt工程的无限可能，未来或许还能开拓更直接的人机交互方式。在这技术变革的洪流中，洞悉技术背后的本质原理与保持开放的学习心态，远比拘泥于某种具体实现形式更为宝贵——因为代码的形态会不断迭代，而创新的精神却是恒久不变的。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>本文收录了，基于结构化提示词驱动开发方法论，创建的API相关CRUD操作以及测试模板集（<a target="_blank" rel="noopener" href="https://github.com/gszhangwei/structured-prompts-driven-development/tree/main"><strong>点击这个链接</strong></a>），这些模板已经过实践验证并可直接应用于日常开发。诚挚地邀请各位开发者在使用这些基础模板的同时，根据自身项目需求进行创新与扩展，共同推动这一方法论的持续演进。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/02/27/prompts-driven-development/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/prompts-driven-development/" class="post-title-link" itemprop="url">结构化提示词驱动开发实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 17:00:00" itemprop="dateCreated datePublished" datetime="2025-02-27T17:00:00+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-28 16:48:41" itemprop="dateModified" datetime="2025-02-28T16:48:41+08:00">2025-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上周六参加了公司组织的关于AI实践的对外直播，我分享的内容是《结构化提示词驱动开发实践》。现在将其记录成一篇博客，在此与大家分享我们团队在提示词驱动开发领域的一些实践与思考。随着大语言模型的不断成熟，我们逐步认识到，如何高效运用结构化提示词，引导AI生成高质量代码，已成为提升软件开发效率与质量的关键所在。本文将围绕“<strong>结构化提示词驱动开发</strong>”这一主题，从设计理念、实践路径到治理策略，全面解析提示词在软件开发中如何落地应用，并以数据与实例展示其显著成效。</p>
<h2 id="解锁解决方案：克服关键挑战"><a href="#解锁解决方案：克服关键挑战" class="headerlink" title="解锁解决方案：克服关键挑战"></a>解锁解决方案：克服关键挑战</h2><p>在早期的AI辅助开发过程中，我们曾经深刻体会到传统开发模式的诸多局限。常规的对话式代码生成往往存在如下问题：生成的代码可用性不足、质量参差不齐，以至于后续大量人工返工成为常态；同时，对话式生成方案不易形成固化、可复用的工程产物，制约了AI在工程级项目中的大规模应用。数据显示，AI生成代码的采纳率普遍低于50%，而代码质量的波动也使得实际交付面临诸多风险。</p>
<p>正因如此，我们开始思考：如果能够突破这些障碍，充分激发AI在交付过程中的潜能，那么软件开发的方式将会迎来怎样的变革？经过反复探索与实践，我们认为解决这一问题需要三大能力作支撑：</p>
<ul>
<li>第一是迅速分析问题，并精准识别出根本原因，从而为后续提供有效解决方案；</li>
<li>第二是依托严谨的工程实践，通过标准流程来保障代码质量；</li>
<li>第三也是最为关键的，即通过使用结构化提示词，让AI生成的代码具备可解释性、可追溯性和高采纳率。<br><img src="/../images/Challenge_and_Solution.png" alt="Challenge_and_Solution.png"><br>正是这三大支柱构成了我们突破传统模式、推动AI赋能开发的核心思路，也为后续实践提供了坚实的理论基础和指导方向。</li>
</ul>
<h2 id="试点项目探索与验证"><a href="#试点项目探索与验证" class="headerlink" title="试点项目探索与验证"></a>试点项目探索与验证</h2><p>为了验证这一方法论的可行性，我们开展了一系列试点项目，尽管具体业务细节不便透露，但整体项目任务包括了前端服务的初始化、基础设施及持续集成（CI）的搭建、前后端代码与测试的新编写，以及现有前端系统的重构。项目交付后，通过对数据的详细采集与对比分析，我们获得了非常振奋的成果。</p>
<p>例如，在从零开始构建系统的任务中，传统开发模式需要消耗约19人天，而采用结构化提示词模式后，仅耗时7人天，且代码采纳率高达95%，这不仅大幅缩短了开发周期，也使得生产力实现近3倍的提升。而针对遗留系统的需求响应，开发时间则由原先的5人天缩短至3人天，生产效率提升约1.7倍。此外，我们还观察到，通过这种模式，代码重复率显著降低，单元测试覆盖率由65%增加至96%。这些数据充分说明，结构化提示词不仅提高了交付效率，更在实际工程中提升了代码质量和系统稳定性。<br><img src="/../images/Background_of_Project.png" alt="Background_of_Project.png"><br>数据背后的意义在于，我们成功为AI赋能软件开发找到了一条有效路径，这种路径打破了传统开发方式的局限，将原本模糊难控的生成过程转化为可管理、可复制的工程实践，为整个团队带来了崭新的开发体验和惊人的效率提升。</p>
<p>让我们先探讨如何在软件开发领域中构建有效提示词，再逐步回顾我们所做的具体实践。</p>
<h2 id="结构化提示词设计框架"><a href="#结构化提示词设计框架" class="headerlink" title="结构化提示词设计框架"></a>结构化提示词设计框架</h2><h3 id="如何有效构建提示词？"><a href="#如何有效构建提示词？" class="headerlink" title="如何有效构建提示词？"></a>如何有效构建提示词？</h3><p>在软件开发领域利用自然语言驱动AI生成代码过程中，一个根本性矛盾一直存在：人类思维具有天然的发散性，而AI执行指令则要求极高的结构化和精确性。传统提示词设计容易陷入两种误区：一方面，开发者可能过分依赖表面化描述，如直接要求“生成800字带小标题的营销文案”，这种方式虽然直白，但往往流于形式；另一方面，则可能陷入抽象概念的模糊描述，让AI自行揣测具体意图，从而导致输出偏离预期目标。</p>
<p>为突破这一矛盾，我们强调思维方式的跃迁，即要从简单的特征描述（例如颜色、形状等外在属性）转向对事物本质的抽象提炼（例如功能内核与运行机制）。只有当我们首先明确定义对象的核心功能与本质特性，再辅以具体细节描述，才能为AI提供一条唯一且明确的生成路径，最大程度降低AI的幻觉。例如，在需要生成一个“白色冰箱”的场景中（假设我们并不知道冰箱这一名词概念），如果仅以“生成一个四方形白色物体，下方有四个小轮子”进行描述，可能误导AI产生与冰箱无关的对象；而若从本质出发，先定义“维持低温环境”这一核心功能，然后再补充其它特征，便能精准锁定冰箱这一概念，同时也为其它如冷库、冷链车留下一定扩展空间。正如我们所倡导的，“特征决定细节，本质决定边界”，只有先明晰本质，后注重具体细节，才能确保生成结果符合预期。<br><img src="/../images/Construct_prompts_effectively.png" alt="Construct_prompts_effectively.png"></p>
<h3 id="组件描述法在提示词构建中的实践"><a href="#组件描述法在提示词构建中的实践" class="headerlink" title="组件描述法在提示词构建中的实践"></a>组件描述法在提示词构建中的实践</h3><p>基于上述理念，在构建提示词时我们引入了组件描述法。以后端开发为例，我们为每个组件设计了涵盖类名、方法名、异常处理等在内的多达10个标准化维度。通过这种方法，每个组件不仅能够明确界定其功能边界，也实现了逻辑上的严谨封装。需要说明的是，这里的“组件”概念与传统开发框架中的概念有所不同，它指的是构成结构化提示词的基本单元，是对功能职责和实现过程的细致拆解。<br><img src="/../images/Component_Description.png" alt="Component_Description.png"><br>组件描述法的引入，使得每个提示词单元既自成体系又相互衔接，在明确各自核心职责的同时，通过精准定义其属性和操作范围，有效避免了各组件之间的混淆和重叠，保障了整体提示词的严密性和生成代码的一致性。这样的设计不仅极大增强了系统的可维护性，也为处理复杂业务场景提供了有力支撑。</p>
<h3 id="结构化Prompt设计整体框架"><a href="#结构化Prompt设计整体框架" class="headerlink" title="结构化Prompt设计整体框架"></a>结构化Prompt设计整体框架</h3><p>在组件定义的基础上，我们进一步构建了完整的结构化Prompt设计框架，该框架总体分为以下五个部分：</p>
<p>需求锚定阶段要求我们准确描述业务需求，确保开发目标的精准定位；结构定义阶段则负责明确实现功能所需模块之间的依赖关系和相互作用；任务编排阶段将整体需求拆解成具体操作单元，通过逐一定义各组件来形成连续的工作流；在通用任务阶段，我们对数据校验、异常处理等高频操作进行标准化处理，以模板化的方式复用解决方案；最后，约束控制阶段为整个系统设置安全围栏，限定组件调用的范围和引用关系，防止因边界不清引发的潜在问题。</p>
<p>在此过程中，我们始终坚持两个黄金准则：首先，本质抽象必须优先于特征描述，只有清晰定义组件的核心职责，才能避免陷入形式化穷举的困境；其次，组件应被视为逻辑单元，而非仅仅是代码片段，就如一部优秀剧本强调刻画人物内在动机，而非干涉演员细微表现。正是在这两个准则的指引下，结构化Prompt设计框架为团队构建了一套系统、严谨且高效的提示词应用体系，极大地提升了整体开发效率和代码质量。<br><img src="/../images/Structured_prompts_strategy.png" alt="Structured_prompts_strategy.png"></p>
<h2 id="提示词工程：AI资产的治理策略"><a href="#提示词工程：AI资产的治理策略" class="headerlink" title="提示词工程：AI资产的治理策略"></a>提示词工程：AI资产的治理策略</h2><p>要确保提示词在长期开发过程中的持续有效性，仅仅构建高质量提示词是不够的，还需要建立一套完善的治理策略。我们将提示词治理分为多个层级：规则层、行业垂直方案抽象层、解决方案具体实现层以及AI执行层。各层级之间分工明确，架构师、技术负责人与开发工程师各自履行职责，共同维护提示词资产的高标准和可持续性。<br><img src="/../images/prompts_governance_policy.png" alt="prompts_governance_policy.png"><br>目前，在试点项目中，我们已经通过预定义工作流引入日志规则，将其置于规则层，确保在代码生成前通过提示词预先注入必要的安全和质量标准。这不仅使得生成代码符合日志规范，同时也为整个系统构建起一道坚固的防护屏障。随着实施的不断推进，这一治理策略将逐步完善并推广到更广泛的开发场景中，为软件工程在质量控制和流程管理上提供制度化保障。</p>
<h2 id="项目实践实例解析"><a href="#项目实践实例解析" class="headerlink" title="项目实践实例解析"></a>项目实践实例解析</h2><p>为了更直观地展示结构化提示词的应用效果，我们以一个获取用户权限信息的API项目为例进行说明。该API不仅需支持根据用户ID、邮箱、姓名及角色进行多条件查询，还要求具备分页、排序以及对数据进行分组合并的功能。在实际开发中，我们依照需求、结构、任务、通用任务与约束控制等模块，系统地组织和编写提示词，同时在组件定义中严格遵循组件描述法和构建提示词的核心指导思想。依托这一完备的体系，我们最终实现了一个能够根据多参数动态构建查询条件，并对数据进行复杂分组与合并操作的API。</p>
<p>统计结果显示，在后端实现API模块，团队共使用6组提示词，总行数达592行，最终生成代码1849行，涉及37个文件的新增或修改。如此覆盖复杂业务场景的实践成果，不仅充分验证了结构化提示词模式的可行性，也大大提升了交付效率和代码质量，为传统开发模式带来了全新的变革思路。<br><img src="/../images/Examples_of_project_practices.png" alt="Examples_of_project_practices.png"><br>在项目推进过程中，我们也直面了一些实际问题，并据此积累了宝贵经验。尤其对于初次接触该模式的团队而言，我们发现并不需要从零开始书写提示词，而可以从现有代码中提炼有效提示，从而逐步优化和完善提示体系，实现快速落地和迭代。</p>
<h2 id="有效撰写提示词的技巧与实战建议"><a href="#有效撰写提示词的技巧与实战建议" class="headerlink" title="有效撰写提示词的技巧与实战建议"></a>有效撰写提示词的技巧与实战建议</h2><p>通过多次项目实践，我们总结出如下几种撰写高质量提示词的有效策略。首先，当解决方案已经存在于现有代码中时，可以利用AI自动解析代码，提取出有效提示词，并在此基础上进行优化，这种做法既节约了时间，也避免了从零开始的风险。其次，当解决方案尚存于开发者脑海时，借助可复用的结构化策略，并根据不同任务灵活调整细节，能迅速形成符合预期的提示词。对于那些暂时无解的情况，我们建议先与AI展开开放性协作探索，通过不断收敛思路后，借助结构化模板生成初步提示词，再由开发者进行必要的人工微调和确认。</p>
<p>在实践中我们还发现，写作提示词时应特别注意避免过度抽象。对于简单场景，往往无需构建复杂的提示体系，此时采用直接的对话式编程反而更为高效。此外，提示词的撰写要做到本质与特征兼顾——既要确保功能和职责的清晰表述，又不能忽略细节描述的重要性。最关键的是，无论是为了让AI生成优秀代码，还是为了便于开发者后期审核修正，最终形成的提示词都必须具备良好的可读性和实用性，能够以清晰自然的语言传达预期意图。<br><img src="/../images/Advice_of_practice.png" alt="Advice_of_practice.png"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总体而言，提示词驱动开发作为一种全新的软件开发模式，展现出前所未有的创新潜力。凭借结构化提示词的系统设计与严格治理策略，我们不仅成功激发了AI在代码生成中的潜能，还显著提升了开发效率和代码质量，为我们团队引入了全新的思考方式和工作模式。</p>
<p>展望未来，我们将持续关注AI技术的前沿动态，并在更为复杂的实际场景下不断完善提示词设计与治理体系。我们期待，在广大开发者不断探索和实践的推动下，人与AI的深度融合能够开启软件开发的新纪元，共同推动整个行业迈向更高效、更智能的未来。通过不断迭代与优化，相信结构化提示词必将成为工程实践中的一项核心技术，为软件开发注入源源不断的创新动力和竞争优势。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>这篇文章在外部发表后，大家围绕“特征决定细节，本质决定边界”展开了一些讨论。但我发现，大家对“特征”和“本质”的基本定义可能存在不同理解。为此，我在这里补充了它们的基本定义，以便统一认知，从而帮助大家更好地理解这句话的深层含义。<br>特征（Features）：指问题或需求中可观测、可描述的具体属性，包括输入输出形式、约束条件、交互场景、技术参数等显性要素。核心特点：可量化，可验证，具象化（容易观察到的）。<br>本质（Essence）：指问题背后需要解决的根本矛盾或核心目标，是决定解决方案有效性的底层逻辑。核心特点：抽象性，方向性，不可妥协性（那个能够决定成为它的东西）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="hhttps://gszhangwei.github.io/2025/02/27/prompt-driven-development-en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wiilie Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willie's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/prompt-driven-development-en/" class="post-title-link" itemprop="url">Structured prompts driven development</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 17:00:00" itemprop="dateCreated datePublished" datetime="2025-02-27T17:00:00+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-03 12:07:28" itemprop="dateModified" datetime="2025-03-03T12:07:28+08:00">2025-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Recently, I took part in an external livestream hosted by our company in China, where I presented on the topic of ‘Structured Prompt-Driven Development Practice. I am now recording this experience as a blog post to share some of our team’s practices and reflections on prompt-driven development. As large language models continue to mature, we are increasingly realizing that efficiently leveraging structured prompts to guide AI in generating high-quality code is key to improving both software development efficiency and quality. This article, centered on <strong>Structured Prompt-Driven Development</strong>, comprehensively analyzes how prompts can be applied in software development—from design philosophy and practical implementation to governance strategies—supporting our discussion with data and practical examples.</p>
<h2 id="Unlocking-Solutions-Overcoming-Key-Challenges"><a href="#Unlocking-Solutions-Overcoming-Key-Challenges" class="headerlink" title="Unlocking Solutions: Overcoming Key Challenges"></a>Unlocking Solutions: Overcoming Key Challenges</h2><p>In the early stages of AI-assisted development, we experienced firsthand the many limitations of conventional development models. The typical conversational code generation approach often suffers from several issues: the generated code frequently lacks usability and exhibits uneven quality, leading to extensive manual rework; moreover, conversational generation methods do not readily produce fixed, reusable engineering deliverables, which limits the large-scale application of AI in enterprise-level projects. Data shows that the adoption rate of AI-generated code is generally below 50%, and the fluctuations in code quality pose significant risks for actual delivery.</p>
<p>This led us to ponder: if we could overcome these obstacles and fully harness the potential of AI during the delivery process, how might software development transform? After extensive exploration and practical trials, we determined that addressing these challenges requires three core capabilities:</p>
<ul>
<li>The ability to quickly analyze problems and accurately identify root causes, thereby providing effective subsequent solutions.</li>
<li>A reliance on rigorous engineering practices that ensure code quality through standardized processes.</li>
<li>Most critically, employing structured prompts that enable AI to generate code which is interpretable, traceable, and highly adoptable.</li>
</ul>
<p>Challenge_and_Solution.png</p>
<p>These three pillars form the core of our breakthrough from traditional methodologies and drive our AI-empowered development approach, providing a solid theoretical foundation and clear guidance for our subsequent practices.</p>
<h2 id="Pilot-Project-Exploration-and-Validation"><a href="#Pilot-Project-Exploration-and-Validation" class="headerlink" title="Pilot Project Exploration and Validation"></a>Pilot Project Exploration and Validation</h2><p>To validate the feasibility of our methodology, we conducted a series of pilot projects. Although specific business details cannot be disclosed, the overall project tasks included initializing new frontend services, setting up infrastructure and continuous integration (CI), writing new backend and frontend code and tests, and refactoring existing frontend systems. After project delivery, detailed data collection and comparative analysis yielded remarkably encouraging results.</p>
<p>For instance, in a system built from scratch, the traditional development model required approximately 19 man-days, whereas the structured prompt-driven approach took only 7 man-days—with a code adoption rate as high as 95%. This not only reduced the development cycle dramatically but also nearly tripled productivity. Similarly, for legacy system requirements, development time was reduced from 5 to 3 man-days, representing about a 1.7-times improvement in efficiency. Additionally, we observed a significant reduction in code duplication and an increase in unit test coverage from 65% to 96%. These results clearly demonstrate that structured prompts not only improve delivery efficiency but also enhance code quality and overall system stability.</p>
<p>Background_of_Project.png</p>
<p>The significance of these results is that we have successfully discovered an effective path to harness AI for software development. This approach breaks through the limitations of traditional methods by transforming the inherently ambiguous generation process into a manageable, replicable engineering practice—bringing our team a brand-new development experience along with astonishing efficiency gains.</p>
<p>Let’s first explore how to construct effective prompts in the realm of software development, and then review our specific practices.</p>
<h2 id="Structured-Prompt-Design-Framework"><a href="#Structured-Prompt-Design-Framework" class="headerlink" title="Structured Prompt Design Framework"></a>Structured Prompt Design Framework</h2><h3 id="How-to-Construct-Effective-Prompts"><a href="#How-to-Construct-Effective-Prompts" class="headerlink" title="How to Construct Effective Prompts?"></a>How to Construct Effective Prompts?</h3><p>In software development, using natural language to drive AI code generation presents a fundamental contradiction: human thinking is inherently divergent, while AI requires highly structured and precise instructions. Traditional prompt design can fall into two pitfalls. On one hand, developers might overly rely on superficial descriptions—such as simply asking “Generate an 800-word marketing copy with subheadings.” Although straightforward, this approach often turns out to be formulaic. On the other hand, overly abstract descriptions leave too much room for interpretation, causing AI to stray from the intended target.</p>
<p>To overcome this contradiction, we emphasize a shift in thinking—from merely describing features (like color or shape) to abstracting the essence of an object (its core functionality and operational mechanism). Only by first clearly defining an object’s core function and essential characteristics, and then supplementing that with specific details, can we provide AI with a unique, unambiguous generation path that minimizes “hallucinations.” For example, consider a scenario where we need to generate a “white refrigerator” (assuming we are not familiar with the abstract concept of a refrigerator). If we only describe it as “a square white object with four small wheels at the bottom,” AI might produce something unrelated to a refrigerator. However, if we begin by defining its essential function as “maintaining a low-temperature environment” and then add additional feature details, we can accurately target the concept of a refrigerator while still leaving room for related ideas such as cold storage or refrigerated trucks. As we advocate, “features determine details, while essence defines boundaries.” Only by clearly articulating the essence first and then supplementing with specifics can we ensure that the generated outcome aligns with our expectations.</p>
<p>Construct_prompts_effectively.png</p>
<h3 id="Application-of-the-Component-Description-Method-in-Prompt-Construction"><a href="#Application-of-the-Component-Description-Method-in-Prompt-Construction" class="headerlink" title="Application of the Component Description Method in Prompt Construction"></a>Application of the Component Description Method in Prompt Construction</h3><p>Based on the above philosophy, we introduced the component description method into our prompt construction. Taking backend development as an example, we designed up to 10 standardized dimensions for each component, covering aspects such as class names, method names, and exception handling. This method does not simply replicate the conventional framework concept; rather, the “components” here represent the basic units of a structured prompt that break down both functional responsibilities and the implementation process in detail.</p>
<p>Component_Description.png</p>
<p>The introduction of the component description method ensures that each prompt element is both self-contained and seamlessly integrated with others. By clearly defining its core responsibility and precisely specifying attributes and operational scope, we effectively avoid confusion and overlap between components, thereby safeguarding the integrity of the overall prompt and ensuring consistency in the generated code. This design not only significantly enhances maintainability but also provides robust support for tackling complex business scenarios.</p>
<h3 id="Overall-Framework-for-Structured-Prompt-Design"><a href="#Overall-Framework-for-Structured-Prompt-Design" class="headerlink" title="Overall Framework for Structured Prompt Design"></a>Overall Framework for Structured Prompt Design</h3><p>Building on the component definitions, we further established a comprehensive framework for structured prompt design, divided into the following five parts:</p>
<ul>
<li><strong>Requirement Anchoring:</strong> Accurately describing business requirements to ensure precise development targets.</li>
<li><strong>Structural Definition:</strong> Clarifying the dependencies and interactions among the modules required to implement functionality.</li>
<li><strong>Task Scheduling:</strong> Breaking down overall requirements into specific operational units and systematically defining each component to form a coherent workflow.</li>
<li><strong>Common Tasks:</strong> Standardizing high-frequency operations—such as data validation and exception handling—using template-driven solutions.</li>
<li><strong>Constraint Control:</strong> Setting up safety boundaries for the entire system by limiting the scope of component calls and references to prevent issues arising from unclear boundaries.</li>
</ul>
<p>Throughout this process, we adhere to two golden principles: first, the abstraction of the essence must take precedence over mere feature descriptions—only by clearly defining a component’s core responsibilities can we avoid superficial enumeration. Second, components should be regarded as logical units rather than merely fragments of code; similar to an excellent screenplay that emphasizes a character’s internal motivations rather than dictating every detail of an actor’s performance. Guided by these principles, the framework for structured prompt design has enabled our team to develop a systematic, rigorous, and highly efficient prompting system, thereby greatly enhancing overall development efficiency and code quality.</p>
<p>Structured_prompts_strategy.png</p>
<h2 id="Prompt-Engineering-Governance-Strategy-for-AI-Assets"><a href="#Prompt-Engineering-Governance-Strategy-for-AI-Assets" class="headerlink" title="Prompt Engineering: Governance Strategy for AI Assets"></a>Prompt Engineering: Governance Strategy for AI Assets</h2><p>Ensuring that prompts remain effective throughout the development process requires more than just crafting high-quality prompts—it necessitates a comprehensive governance strategy. We have divided prompt governance into multiple layers: the rule layer, the industry-specific abstract solution layer, the specific solution implementation layer, and the AI execution layer. Responsibilities are clearly delineated across these layers, with architects, technical leads, and developers each playing their part to maintain high standards and sustainability of our prompt assets.</p>
<p>prompts_governance_policy.png</p>
<p>In our pilot projects, we have already integrated logging rules into a predefined workflow, placing them at the rule layer to ensure that, prior to code generation, the necessary safety and quality standards are embedded via prompts. This approach not only ensures that the generated code adheres to logging standards but also builds a robust safety barrier for the entire system. As implementation continues, this governance strategy will be further refined and extended to a broader range of development scenarios, providing structured assurance for quality control and process management in software engineering.</p>
<h2 id="Analysis-of-a-Practical-Project-Example"><a href="#Analysis-of-a-Practical-Project-Example" class="headerlink" title="Analysis of a Practical Project Example"></a>Analysis of a Practical Project Example</h2><p>To illustrate the effectiveness of structured prompts more intuitively, let’s consider an API project for retrieving user permission information. This API is designed not only to support multi-criteria queries based on user ID, email, name, and role, but also to handle pagination, sorting, and the grouping and merging of data. In practice, we systematically organized and written the prompts according to the modules—requirements, structure, tasks, common tasks, and constraint controls. In the component definitions, we strictly adhered to the component description method and the core guiding principles of prompt construction. With this comprehensive framework, we successfully implemented an API that dynamically constructs query conditions based on multiple parameters and handles complex data grouping and merging.</p>
<p>Statistical results indicate that for the backend API module, the team employed 6 sets of prompts totaling 592 lines, which resulted in 1849 lines of generated code and modifications or creations of 37 files. Such a comprehensive practice covering complex business scenarios not only validates the feasibility of the structured prompt model but also significantly enhances delivery efficiency and code quality, heralding a revolutionary approach to traditional development methods.</p>
<p>Examples_of_project_practices.png</p>
<p>During the project, we also encountered real-world challenges and gathered valuable experiences. For teams new to this model, we found that there is no need to write prompts entirely from scratch—effective prompts can be extracted from existing code, thereby enabling rapid implementation and iterative refinement of the prompt system.</p>
<h2 id="Tips-and-Practical-Advice-for-Writing-Effective-Prompts"><a href="#Tips-and-Practical-Advice-for-Writing-Effective-Prompts" class="headerlink" title="Tips and Practical Advice for Writing Effective Prompts"></a>Tips and Practical Advice for Writing Effective Prompts</h2><p>Based on multiple projects, we have developed several strategies for writing high-quality prompts. First, when a solution already exists in current code, AI can be used to automatically parse and extract effective prompts, which can then be further refined. This approach not only saves time but also avoids the risks of starting from scratch. Second, when a solution is still in a developer’s mind, leveraging a reusable structured strategy and adjusting details according to the task at hand can quickly produce prompts that meet expectations. For those situations where the solution is not immediately clear, we recommend engaging in an open collaborative exploration with AI, gradually converging on ideas before using a structured template to generate initial prompts, followed by necessary manual refinement.</p>
<p>Our practical experience has also shown that it is crucial to avoid excessive abstraction when writing prompts. For simpler scenarios, there is often no need to develop an overly complex prompting system; direct conversational coding can be more efficient. Moreover, prompt writing should strike a balance between articulating the essence and detailing features—ensuring clarity in functionality and responsibilities without neglecting essential details. Ultimately, whether the aim is to generate excellent code via AI or to streamline subsequent review and modifications by developers, the final prompts must be both highly readable and practical, conveying the intended idea in clear, natural language.</p>
<p>Advice_of_practice.png</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In summary, prompt-driven development represents a novel software development model with unprecedented innovative potential. With the systematic design of structured prompts and rigorous governance strategies, we have successfully harnessed AI’s potential for code generation while significantly enhancing development efficiency and code quality. This approach has introduced a fundamentally new mode of thinking and working within our team.</p>
<p>Looking ahead, we will continue to monitor cutting-edge AI technologies and further refine our prompt design and governance strategies in even more complex scenarios. We anticipate that, propelled by ongoing exploration and practice by developers, the deep integration of human and AI efforts will usher in a new era in software development—driving the entire industry toward a more efficient and intelligent future. Through continuous iteration and optimization, we are confident that structured prompts will become a core technology in engineering practice, injecting endless innovative energy and competitive advantages into software development.</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><p>After this article was published externally, discussions ensued around the saying “features determine details, while essence defines boundaries” I noticed that there are varying interpretations regarding the basic definitions of “features” and “essence.” Therefore, I have included their fundamental definitions here to harmonize our understanding and help clarify the deeper meaning behind the statement.</p>
<p><strong>Features:</strong><br>Refers to the observable and describable specific attributes of a problem or requirement, including input&#x2F;output formats, constraints, interaction scenarios, technical parameters, and other explicit elements.<br><em>Core characteristics:</em> Quantifiable, verifiable, and concrete (readily observable).</p>
<p><strong>Essence:</strong><br>Refers to the fundamental conflict or core objective underlying a problem, which serves as the foundational logic determining the effectiveness of a solution.<br><em>Core characteristics:</em> Abstract, directional, and non-negotiable (the decisive factor that defines the solution).</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wiilie Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wiilie Zhang</span>
</div>
  <div class="powered-by">
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
