{
    "version": "https://jsonfeed.org/version/1",
    "title": "Willie's Blog • All posts by \"technology\" category",
    "description": "",
    "home_page_url": "https://gszhangwei.github.io",
    "items": [
        {
            "id": "https://gszhangwei.github.io/2025/04/10/AI-workflows-improve-software-development-efficiencyt-en/",
            "url": "https://gszhangwei.github.io/2025/04/10/AI-workflows-improve-software-development-efficiencyt-en/",
            "title": "Structured Prompt-Driven Development Workflow - Transforming Software Development from 2 Days to 1 Hour",
            "date_published": "2025-04-10T04:00:00.000Z",
            "content_html": "<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>Since the publication of <a href=\"https://central.thoughtworks.net/blogs/ls/content/136117101053029/structured-prompts-driven-development-1781b9ae-3d4b-458d-8b8b-0265fa34e1cb\">Structured Prompt-Driven Development in Practice</a>, the feedback I’ve received highlights <strong>two core needs</strong>: <strong>lowering the methodology application threshold</strong> and <strong>providing directly reusable practice templates</strong>.</p>\n<p>As a practitioner who has experienced the transition from traditional development to AI-assisted programming, I deeply feel that software development is currently undergoing a dual transformation: accelerating industry iteration and an efficiency revolution triggered by generative AI. When AI-generated code acceptance rates jump from 30% to 95%, this signals a fundamental paradigm shift in development.</p>\n<p>Facing the reality that methodology is <strong>“easy to understand but difficult to implement”</strong>, could we adopt a progressive model of <strong>“use-understand-innovate”</strong> to help developers naturally master methodological essentials while achieving immediate results?</p>\n<p>In fact, the <strong>universal solution layer</strong> in the structured prompt-driven development methodology can serve as the key breakthrough - <strong>building reusable abstract solution templates</strong>.</p>\n<p>[Prompts Strategy Image Placeholder]</p>\n<p>Our practicing confirms that these templated solutions can reduce the time novices need to build effective prompts <strong>from 2 hours to 30 minutes</strong>, with prompt output quality improving by over 50%.</p>\n<p>This article introduces a battle-tested AI-enhanced software development workflow that has been applied and verified in over a hundred actual development tasks. Through a systematic 5-stage, 14-step process, we’ve observed significant efficiency improvements: development tasks that traditionally required 2 days can now be completed in under 1 hour, achieving nearly 16x speed improvement in optimal cases. This workflow integrates structured prompt engineering with software development best practices, suitable for developers at all experience levels—whether you’re new to AI-assisted development or an experienced engineer seeking efficiency breakthroughs—I hope everyone can derive substantial value from it, significantly accelerating development pace while maintaining or even improving code quality.</p>\n<h2 id=\"Background-and-Tool-Ecosystem\"><a href=\"#Background-and-Tool-Ecosystem\" class=\"headerlink\" title=\"Background and Tool Ecosystem\"></a>Background and Tool Ecosystem</h2><h3 id=\"Limitations-of-Traditional-Development-Processes\"><a href=\"#Limitations-of-Traditional-Development-Processes\" class=\"headerlink\" title=\"Limitations of Traditional Development Processes\"></a>Limitations of Traditional Development Processes</h3><p>Traditional software development processes typically include requirements analysis, design, coding, testing, and deployment. Although agile methodologies have improved iteration speed, developers still need to manually complete numerous repetitive tasks: writing boilerplate code, building test cases, handling edge conditions, etc. While necessary, these tasks consume time that could be used for innovation and solving core business problems.</p>\n<h3 id=\"Core-Tools-Introduction\"><a href=\"#Core-Tools-Introduction\" class=\"headerlink\" title=\"Core Tools Introduction\"></a>Core Tools Introduction</h3><p>My AI-assisted development workflow is primarily built on the following tools:</p>\n<ul>\n<li><strong>Cursor</strong>: AI-driven code editor supporting code generation, completion, refactoring, and intelligent dialogue</li>\n<li><strong>Jira MCP Server</strong>: For obtaining and managing business requirements</li>\n<li><strong>Aupro</strong>: Our engineering practice governance platform, including MCP end, page end, and server end, enabling technology governance teams to establish and share code delivery standards so AI code assistants can generate high-quality code. (<strong>For teams without similar platforms, lightweight alternatives can be adopted</strong>: organizing structured prompt templates in local version control systems through structured folders and clear naming conventions to achieve template management, which can still yield significant benefits)</li>\n<li><strong>Various testing frameworks</strong>: Such as JUnit 5 (Jupiter), etc., working with workflows to implement automated testing</li>\n</ul>\n<p>[AI Development Process Abstract Image Placeholder]</p>\n<h2 id=\"AI-Enhanced-Software-Development-Workflow-Detailed-Analysis-of-5-Stages-and-14-Steps\"><a href=\"#AI-Enhanced-Software-Development-Workflow-Detailed-Analysis-of-5-Stages-and-14-Steps\" class=\"headerlink\" title=\"AI-Enhanced Software Development Workflow: Detailed Analysis of 5 Stages and 14 Steps\"></a>AI-Enhanced Software Development Workflow: Detailed Analysis of 5 Stages and 14 Steps</h2><h3 id=\"Requirements-Analysis-and-Planning-Stage\"><a href=\"#Requirements-Analysis-and-Planning-Stage\" class=\"headerlink\" title=\"Requirements Analysis and Planning Stage\"></a>Requirements Analysis and Planning Stage</h3><ul>\n<li><strong>Requirements Analysis and Solution Conceptualization</strong><ul>\n<li>First, retrieve historical implementations and best practices for similar tasks to establish a knowledge base</li>\n<li>Collaborate with AI to explore technical solutions, quickly evaluating feasibility and tradeoffs of different implementation paths</li>\n<li>Clearly define specific problems AI needs to solve, setting expected outcomes and success metrics</li>\n<li>This step lays the foundation for the entire development process; clear problem definition makes subsequent AI generation more precise and efficient</li>\n</ul>\n</li>\n<li><strong>Requirements Structuring</strong><ul>\n<li>Leverage AI’s natural language processing capabilities to convert business requirements into structured user stories</li>\n<li>Ensure requirement descriptions are complete and include clear acceptance criteria and expected results</li>\n<li>This step transforms abstract business concepts into clear technical tasks, reducing requirement understanding deviations</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Design-and-Solution-Definition-Stage\"><a href=\"#Design-and-Solution-Definition-Stage\" class=\"headerlink\" title=\"Design and Solution Definition Stage\"></a>Design and Solution Definition Stage</h3><ul>\n<li><strong>Implementation Solution Design</strong><ul>\n<li>Apply pre-summarized solution templates to generate structured prompts</li>\n<li>Clearly define technical path, data structures, interface definitions, and key business logic implementation details</li>\n<li>Design staged implementation strategies for complex functionalities, breaking large tasks into manageable small modules</li>\n<li>High-quality prompts are key to obtaining high-quality code output, requiring a combination of business knowledge and technical experience</li>\n</ul>\n</li>\n<li><strong>Solution Detail Adjustment and Optimization</strong><ul>\n<li>Comprehensively evaluate quality, completeness, and technical feasibility of generated prompts</li>\n<li>Analyze whether the solution considers scalability, performance, and long-term maintenance requirements</li>\n<li>Adjust implementation strategies based on business requirements and technical constraints, anticipating potential problems</li>\n<li>This step is equivalent to architecture review in traditional development, ensuring implementation direction is correct</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Code-Development-and-Implementation-Stage\"><a href=\"#Code-Development-and-Implementation-Stage\" class=\"headerlink\" title=\"Code Development and Implementation Stage\"></a>Code Development and Implementation Stage</h3><ul>\n<li><strong>Code Generation and Initial Verification</strong><ul>\n<li>Use optimized prompts to generate implementation code, including basic architecture and core functionality</li>\n<li>Perform quick validation to check if basic functions and code structure meet expectations</li>\n<li>Evaluate whether generated code follows project coding standards and best practices</li>\n</ul>\n</li>\n<li><strong>Code Review and Prompt Fine-tuning</strong><ul>\n<li>Carefully examine code quality, performance, security, and boundary handling</li>\n<li>Identify potential “code smells” and optimization points in the code</li>\n<li>Make targeted adjustments to prompts to address discovered issues, providing clear correction guidance</li>\n<li>This is an iterative optimization process, continuously improving code quality through precise prompt adjustments</li>\n</ul>\n</li>\n<li><strong>Final Code Generation</strong><ul>\n<li>Use finalized prompts to regenerate optimized implementation code</li>\n<li>Ensure code style consistency, readability, and adherence to best practices</li>\n<li>The finalized prompts incorporate optimization experiences from previous iterations, significantly improving generated code quality</li>\n</ul>\n</li>\n<li><strong>Functionality Verification</strong><ul>\n<li>Manually verify core functionality and boundary scenarios to ensure functional completeness</li>\n<li>Perform static code analysis to check code quality metrics and potential issues</li>\n<li>Verify code compatibility and integration points with existing systems</li>\n<li>The verification process checks both functional correctness and code maintainability and performance optimization space</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Testing-and-Quality-Assurance-Stage\"><a href=\"#Testing-and-Quality-Assurance-Stage\" class=\"headerlink\" title=\"Testing and Quality Assurance Stage\"></a>Testing and Quality Assurance Stage</h3><ul>\n<li><strong>Test Prompt Generation</strong><ul>\n<li>Based on solution implementation detail prompts, combined with summarized test prompt templates, generate structured test cases</li>\n<li>Ensure tests cover normal processes, boundary conditions, and exception handling scenarios</li>\n<li>Good test design can prevent future regression issues and serve as living documentation of code functionality</li>\n</ul>\n</li>\n<li><strong>Test Planning Confirmation</strong><ul>\n<li>Review completeness and appropriateness of test scenarios to ensure comprehensive test coverage</li>\n<li>Ensure tests cover not only normal situations but also exception handling and various boundary conditions</li>\n</ul>\n</li>\n<li><strong>Test Code Generation and Execution</strong><ul>\n<li>Use test prompts to generate automated test code, ensuring test code quality</li>\n<li>Execute automated tests and collect detailed results, analyzing test coverage</li>\n<li>Verify whether tests can effectively discover potential problems and boundary situations</li>\n<li>AI-generated tests are often more comprehensive than manually written tests, covering more boundary situations and exception paths</li>\n</ul>\n</li>\n<li><strong>Problem Fixing and Iteration</strong><ul>\n<li>Categorize problem causes based on test results and establish priority fix order</li>\n<li>Make targeted fixes, distinguishing handling strategies: <strong>For uncovered boundary scenarios</strong>, modify implementation code and update corresponding prompts; <strong>For test data issues</strong>, optimize test data without changing implementation logic</li>\n<li>Repeat testing until all tests pass, ensuring code quality and stability</li>\n<li>Record experiences and discoveries during the fixing process as material for prompt template optimization</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Delivery-and-Knowledge-Management-Stage\"><a href=\"#Delivery-and-Knowledge-Management-Stage\" class=\"headerlink\" title=\"Delivery and Knowledge Management Stage\"></a>Delivery and Knowledge Management Stage</h3><ul>\n<li><strong>Integration and Submission</strong><ul>\n<li>Ensure code compatibility with existing systems, verifying integration points work properly</li>\n<li>Submit code and structured prompts solutions to facilitate team understanding of development ideas</li>\n</ul>\n</li>\n<li><strong>Knowledge Precipitation</strong><ul>\n<li>Extract effective prompt patterns and update team template library, forming reusable assets</li>\n<li>Summarize lessons learned, recording successful strategies and challenges encountered</li>\n<li>Share innovative practices and technological breakthroughs, promoting overall team capability improvement</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Core-Advantages-and-Potential-Challenges\"><a href=\"#Core-Advantages-and-Potential-Challenges\" class=\"headerlink\" title=\"Core Advantages and Potential Challenges\"></a>Core Advantages and Potential Challenges</h2><ul>\n<li><p><strong>Core Advantages:</strong></p>\n<ul>\n<li><strong>Structural Benefits</strong>: Structured prompts implement a systematic approach to code generation, creating a more organized and predictable development process while providing a stable framework for consistency.</li>\n<li><strong>Standardization Improvements</strong>: The integration of templates with AI generation techniques significantly enhances both code and test case consistency and completeness, effectively minimizing variations that typically arise from manual development.</li>\n<li><strong>Quality Assurance Framework</strong>: A comprehensive multi-level verification system—spanning from design conception through implementation to functional testing—creates a complete quality control loop that thoroughly ensures code reliability at every stage.</li>\n<li><strong>Significant Efficiency Gains</strong>: Through this optimized methodology, development efficiency achieves remarkable improvement, transforming work that traditionally required two full days into tasks completable within a single hour—representing an approximate 95% reduction in time investment.</li>\n</ul>\n</li>\n<li><p><strong>Potential Challenges:</strong></p>\n<ul>\n<li><strong>Skill Requirement</strong>: Effective prompt engineering mastery requires both technical skill depth and a persistent refinement mindset</li>\n<li><strong>Quality Standard</strong>: It is essential to ensure high-quality structured-prompt documentation and maintainable generated code</li>\n<li><strong>AI Dependency Risk</strong>: Over-reliance dependence on AI may lead to insufficient understanding of generated code</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Practical-Case\"><a href=\"#Practical-Case\" class=\"headerlink\" title=\"Practical Case\"></a>Practical Case</h2><p>Theory needs verification through practice. To better demonstrate the methodology and workflow’s actual effects, I’ve recorded a complete development example video. Welcome to watch and provide valuable suggestions.<br>[Video Placeholder]</p>\n<p>The process shown in the video is mainly summarized as follows:<br>[Sequence Diagram Placeholder]</p>\n<h2 id=\"Best-Practices-and-Experience-Summary\"><a href=\"#Best-Practices-and-Experience-Summary\" class=\"headerlink\" title=\"Best Practices and Experience Summary\"></a>Best Practices and Experience Summary</h2><p><strong>Effective prompts</strong> are the core of the entire workflow. Here are some key techniques:</p>\n<ul>\n<li><strong>Abstract first, then concrete</strong>: Start with task decomposition and framework building, rather than getting bogged down in details initially. First clearly define the abstract steps for implementing functionality and relationships between these steps, then elaborate on each abstract step according to effective prompt construction principles. This “top-down” approach ensures generated code has reasonable structure and clear layers.</li>\n<li><strong>Structured information provision</strong>: Describe solutions following structured prompt-driven development principles, clarifying code generation paths. Structured prompts not only make it easier for AI to understand development intentions but also make subsequent iterations and adjustments clearer and more controllable, laying the foundation for code quality.</li>\n<li><strong>Context association management</strong>: Include necessary association information in prompts, such as inheritance relationships between business models and call relationships between framework layers. Good context association enables AI to understand overall system architecture, generating code that conforms to established architectural styles and design philosophies, reducing later refactoring needs.</li>\n<li><strong>Prompt governance</strong>: Manage effective prompts to form a reusable template library. As projects progress, continuously accumulate and optimize prompt templates, gradually forming a prompt asset library suitable for team and project characteristics, improving long-term efficiency.</li>\n</ul>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p><strong>AI-assisted development</strong> is not just introducing efficiency tools, but <strong>a transformation of software development paradigms</strong>. Through the AI-assisted development workflow introduced in this article, developers can achieve efficient collaboration with AI, delegating repetitive work to AI while <strong>focusing</strong> on more <strong>creative</strong> and <strong>strategic</strong> tasks.</p>\n<p>Practice has proven that using this workflow, after becoming proficient, <strong>development efficiency can improve by at least 3 times</strong> while maintaining or even improving code quality. With continuous advancement of AI technology, there’s even more room for efficiency improvement. For individual developers and teams, now is the best time to embrace this transformation.</p>\n<p>Mastering AI-assisted development is not about replacing developers, but redefining how we work. The real value lies in human-machine collaboration—AI handles execution and assistance, while humans handle innovation and decision-making. Future top developers will be compound talents who both master technology itself and can effectively guide AI to complete tasks.</p>\n<h2 id=\"Some-Thoughts-on-the-Essence-of-Code\"><a href=\"#Some-Thoughts-on-the-Essence-of-Code\" class=\"headerlink\" title=\"Some Thoughts on the Essence of Code\"></a>Some Thoughts on the Essence of Code</h2><p>This transformation also prompts me to rethink the essence of code: <strong>Code itself is a symbolic expression of human intent, constantly evolving with technological development.</strong> From punched paper tapes to assembly language, to high-level languages like C++, Python, Java, etc., each technological innovation has expanded the boundaries of <strong>“what is code.”</strong> Today, as AI can precisely understand human language and intent through specific methods, <strong>natural language programming</strong> becomes a <strong>new stage</strong> in programming paradigms’ natural evolution—not replacing traditional programming but extending it.</p>\n<p>Different programming paradigms each have their value and scenarios, just as in transportation’s historical evolution, new technology doesn’t mean complete elimination of old technology. Forward-thinking developers will be inclusive—mastering traditional programming’s rigorous structure while using that experience to explore more possibilities in prompt engineering, perhaps even developing more direct human-machine interaction methods in the future. In technological change waves, understanding essential principles behind technology and maintaining an open learning attitude are far more important than adhering to specific implementation forms—<strong>Code forms will continue to iterate, while the spirit of innovation remains constant.</strong></p>\n<p>Let us actively embrace this transformation, rethink the essence of software development, and create greater value in the new era of human-machine collaboration.</p>\n<h2 id=\"Appendix\"><a href=\"#Appendix\" class=\"headerlink\" title=\"Appendix\"></a>Appendix</h2><p>As a practical tool for this methodology, we provide a set of battle-tested prompt templates covering API CRUD operations and accompanying test strategies (click this link to view the complete template library). These templates can not only be used directly in daily development but also serve as examples for learning structured prompt engineering.</p>\n<p>We sincerely invite all developers to innovate and expand based on their own project needs while using these basic templates, jointly promoting the continuous evolution of this methodology.</p>\n",
            "tags": [
                "AI",
                "Prompts"
            ]
        }
    ]
}